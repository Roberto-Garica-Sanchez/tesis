
#include <18F4550.h>
#device ADC=10 
#fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,BROWNOUT,INTRC_IO  
#use delay(clock=4000000) 
   #define lcd_type 1 
#INCLUDE <LCD.C>
#USE STANDARD_IO(A)
#USE STANDARD_IO(B)
#USE STANDARD_IO(C)
#USE STANDARD_IO(D)
#USE STANDARD_IO(E)
//configuracion entradas/salidas
//entradas
   #define PIN_SetPoint  0    //[AN0]setpoint      set_adc_channel(0); set_adc_channel(PIN_SetPoint); 
   #define PIN_PocitionReal 1 //[AN1]posicion real set_adc_channel(1); set_adc_channel(PIN_PocitionReal); 
//salidas
    //control puenta H
        //Grupos de rotacion 
            //set_pwm1_duty() [RC2]
        //B
            //set_pwm1_duty() [RC3]
//bits
unsigned int16 bits_SetPoint=0;
unsigned int16 bits_PocitionReal=0;
unsigned int16 bits_difer=0;

//var PID
float Var_SetPoint=0;
float Var_PocitionReal=0;
float Var_error=0;
//variable temporales 
//int16 temp,a,b,c;
//VAR PWM
int16 duty=0;
int Timer2,Poscaler;
//VAR motor 
int cambio,giro=1;
//#########     PID
float a,b,c;            //variables temporales
float t=1;              //periodo de muestreo 
float e[100];           //error
int k=0;              //contrador de muestras
float u[100];            //Salidas
//#########    ganancias
float kd=1;               //Derivativa
float ki=0.5;               //integral
float kp=0.5;               //proporcional


float32 map(float32 valor, float32 entradaMin, float32 entradaMax, float32 salidaMin, float32 salidaMax)    
{                                
    return ((((valor-entradaMin)*(salidaMax-salidaMin))/(entradaMax-entradaMin))+salidaMin); 
}  
void main() { 
   Timer2=249;    //Se carga timer 2 con 249
   Poscaler=1;  //Preescaler solo puede tomar valores de: 1
   
   setup_timer_2(t2_div_by_4,Timer2,Poscaler);   //Configuracion de Timer 2 para establecer frec. PWM a 1kHz
   setup_ccp1(ccp_pwm);                //Configurar modulo CCP1 en modo PWM
   setup_ccp2(ccp_pwm);                //Configurar modulo CCP2 en modo PWM
   setup_adc_ports(all_analog);        //Configurar ADC configuracion de los puertos que funcionan en analogico 
   setup_adc(adc_clock_internal);
   
   LCD_INIT();       //Inicializa el LCD
   LCD_PUTC("\f");   //Borrar el contenido del LCD
   while(true){
      //leer setpoint 
         set_adc_channel(PIN_SetPoint);            //selecciona valore deseado setpoint  
         delay_us(100);       
         bits_SetPoint=read_adc();   
      //leer posicion real 
         set_adc_channel(PIN_PocitionReal);        //seleciona la posicion real 
         delay_us(100);       
         bits_PocitionReal=read_adc();               //leer            
      //calculos 
         //convierte loas bits en voltaje 
         Var_SetPoint      = (5.0*bits_SetPoint)/1024.0;
         Var_PocitionReal  = (5.0*bits_PocitionReal)/1024.0;
         bits_difer=bits_PocitionReal-bits_SetPoint;
         Var_error=Var_PocitionReal-Var_SetPoint;
         //diferencia de voltaje 
         c=Var_PocitionReal-Var_SetPoint;
         //PID Calculos //muestreo
            e[k]=Var_error;
            
        //calculo
            /*
            a=e[k]  *( kp + (ki*t) )+( kd/t );
            b=e[k-1]*( (-2*(kd/t) - kp) );
            c=e[k-2]*( (kd/t) +u[k-1] );
            u[k]=a+b+c;
            */
        //incremento en contrador 
            k=k+1;
                   
      //interface
      LCD_GOTOXY(1,1);       
      printf(lcd_putc," %4Lu",bits_SetPoint);  
      printf(lcd_putc," %4Lu",bits_PocitionReal);  
      printf(lcd_putc," %4Lu",bits_difer);  
      LCD_GOTOXY(1,2);        
      printf(lcd_putc," %f",Var_SetPoint);         lcd_putc("V");
      printf(lcd_putc," %f",Var_PocitionReal);     lcd_putc("V");
      printf(lcd_putc," %f",Var_error);            lcd_putc("V");
      LCD_GOTOXY(1,3);        
      printf(lcd_putc," %i",k);            
      printf(lcd_putc," %f", e[k]);            
      // EL SISGUIENTE CODIGO SE ENCARGA DE CONVERTIR el valor de salida del pid en 
      //valores validos para el puente h de dos hilos 
      //el sentido de giro se definira por el signo ->0<+
      
      /*
      if(Var_PocitionReal<Var_SetPoint){     
         c=Var_SetPoint-Var_PocitionReal;
         set_pwm1_duty(c);          //write salida de señal PWM 
         output_high(PIN_B1);       //led indicador de giro 
      }else{output_low(PIN_B1); set_pwm1_duty(0);}
      if(Var_PocitionReal>Var_SetPoint){  
         c=Var_PocitionReal-Var_SetPoint;
         set_pwm2_duty(c);          //write salida de señal PWM          
         output_high(PIN_B2);       //led indicador de giro 
      }else{output_low(PIN_B2);set_pwm2_duty(0);} //si el sentido de giro no corresponde apaga el led y PWM
      if(Var_SetPoint==Var_PocitionReal){
         set_pwm2_duty(0);
         set_pwm1_duty(0);
      }
      */
     //reinicio de las memorias 
     if(k>=20){
         k=0; 
         for (int i = 0; i <100; i++){
               e[i]=0;
         }
         
      }
   }
}

