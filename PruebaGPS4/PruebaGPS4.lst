CCS PCH C Compiler, Version 5.015, 5967               11-ene.-21 11:57

               Filename:   D:\escuela\tesis\PruebaGPS4\PruebaGPS4.lst

               ROM used:   19352 bytes (59%)
                           Largest free fragment is 13416
               RAM used:   339 (17%) at main() level
                           409 (20%) worst case
               Stack used: 7 locations
               Stack size: 31

*
0000:  GOTO   2B10
.................... #define time_offset   -18000   // define a clock offset of 3600 seconds (1 hour) ==> UTC + 1 
....................  
.................... //LCD module connections PUERTO D  
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
.................... #define LCD_ENABLE_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 20,44
0006:  DATA 4F,4D
0008:  DATA 49,4E
000A:  DATA 47,4F
000C:  DATA 20,20
000E:  DATA 00,00
0010:  DATA 20,4C
0012:  DATA 55,4E
0014:  DATA 45,53
0016:  DATA 20,20
0018:  DATA 00,00
001A:  DATA 20,4D
001C:  DATA 41,52
001E:  DATA 54,45
0020:  DATA 53,20
0022:  DATA 00,00
0024:  DATA 4D,49
0026:  DATA 45,52
0028:  DATA 43,4F
002A:  DATA 4C,45
002C:  DATA 53,00
002E:  DATA 4A,55
0030:  DATA 45,56
0032:  DATA 45,53
0034:  DATA 20,00
0036:  DATA 20,56
0038:  DATA 49,45
003A:  DATA 52,4E
003C:  DATA 45,53
003E:  DATA 20,20
0040:  DATA 00,00
0042:  DATA 53,41
0044:  DATA 42,41
0046:  DATA 44,4F
0048:  DATA 20,00
004A:  DATA 49,4E
004C:  DATA 49,43
004E:  DATA 49,41
0050:  DATA 4E,44
0052:  DATA 4F,20
0054:  DATA 53,49
0056:  DATA 53,54
0058:  DATA 45,4D
005A:  DATA 41,20
005C:  DATA 0A,20
005E:  DATA 20,45
0060:  DATA 53,50
0062:  DATA 45,52
0064:  DATA 45,2E
0066:  DATA 2E,2E
0068:  DATA 2E,00
006A:  DATA 0C,00
006C:  DATA 41,6C
006E:  DATA 62,61
0070:  DATA 3A,20
0072:  DATA 25,66
0074:  DATA 00,00
0076:  DATA 4F,63
0078:  DATA 61,73
007A:  DATA 6F,3A
007C:  DATA 20,25
007E:  DATA 66,00
0080:  DATA 41,6C
0082:  DATA 62,61
0084:  DATA 3A,20
0086:  DATA 25,66
0088:  DATA 00,00
*
02EE:  TBLRD*+
02F0:  MOVF   FF5,F
02F2:  BZ    030C
02F4:  MOVFF  FF6,143
02F8:  MOVFF  FF7,144
02FC:  MOVFF  FF5,14E
0300:  RCALL  0282
0302:  MOVFF  143,FF6
0306:  MOVFF  144,FF7
030A:  BRA    02EE
030C:  RETURN 0
*
06A8:  MOVLB  1
06AA:  CLRF   x58
06AC:  CLRF   x59
06AE:  MOVLW  01
06B0:  MOVWF  x5A
06B2:  CLRF   FDA
06B4:  CLRF   FD9
06B6:  MOVWF  x5D
06B8:  MOVLW  50
06BA:  MOVWF  x5C
06BC:  MOVLW  01
06BE:  MOVWF  FEA
06C0:  MOVLW  54
06C2:  MOVWF  FE9
06C4:  MOVFF  15D,FE2
06C8:  MOVFF  15C,FE1
06CC:  MOVFF  15A,15B
06D0:  BCF    FD8.0
06D2:  MOVF   FE5,W
06D4:  MULWF  FEE
06D6:  MOVF   FF3,W
06D8:  ADDWFC x58,F
06DA:  MOVF   FF4,W
06DC:  ADDWFC x59,F
06DE:  DECFSZ x5B,F
06E0:  BRA    06D0
06E2:  MOVFF  158,FDE
06E6:  MOVFF  159,158
06EA:  CLRF   x59
06EC:  BTFSC  FD8.0
06EE:  INCF   x59,F
06F0:  INCF   x5C,F
06F2:  BTFSC  FD8.2
06F4:  INCF   x5D,F
06F6:  INCF   x5A,F
06F8:  MOVF   x5A,W
06FA:  SUBLW  05
06FC:  BNZ   06BC
06FE:  MOVLB  0
0700:  RETURN 0
0702:  CLRF   01
0704:  CLRF   02
0706:  CLRF   00
0708:  CLRF   03
070A:  MOVLB  1
070C:  MOVF   x53,W
070E:  BNZ   0714
0710:  MOVF   x52,W
0712:  BZ    0744
0714:  MOVLW  10
0716:  MOVWF  x54
0718:  BCF    FD8.0
071A:  RLCF   x50,F
071C:  RLCF   x51,F
071E:  RLCF   00,F
0720:  RLCF   03,F
0722:  MOVF   x53,W
0724:  SUBWF  03,W
0726:  BNZ   072C
0728:  MOVF   x52,W
072A:  SUBWF  00,W
072C:  BNC   073C
072E:  MOVF   x52,W
0730:  SUBWF  00,F
0732:  BTFSS  FD8.0
0734:  DECF   03,F
0736:  MOVF   x53,W
0738:  SUBWF  03,F
073A:  BSF    FD8.0
073C:  RLCF   01,F
073E:  RLCF   02,F
0740:  DECFSZ x54,F
0742:  BRA    0718
0744:  MOVLB  0
0746:  RETURN 0
*
07D0:  MOVLB  1
07D2:  MOVF   x4E,W
07D4:  CLRF   01
07D6:  SUBWF  x4D,W
07D8:  BC    07E0
07DA:  MOVFF  14D,00
07DE:  BRA    07F8
07E0:  CLRF   00
07E2:  MOVLW  08
07E4:  MOVWF  x4F
07E6:  RLCF   x4D,F
07E8:  RLCF   00,F
07EA:  MOVF   x4E,W
07EC:  SUBWF  00,W
07EE:  BTFSC  FD8.0
07F0:  MOVWF  00
07F2:  RLCF   01,F
07F4:  DECFSZ x4F,F
07F6:  BRA    07E6
07F8:  MOVLB  0
07FA:  RETURN 0
*
085E:  BTFSC  FD8.1
0860:  BRA    086A
0862:  MOVLW  01
0864:  MOVWF  FEA
0866:  MOVLW  60
0868:  MOVWF  FE9
086A:  MOVLB  1
086C:  MOVF   x5B,W
086E:  XORWF  x5F,W
0870:  ANDLW  80
0872:  MOVWF  x65
0874:  BTFSS  x5B.7
0876:  BRA    088E
0878:  COMF   x58,F
087A:  COMF   x59,F
087C:  COMF   x5A,F
087E:  COMF   x5B,F
0880:  INCF   x58,F
0882:  BTFSC  FD8.2
0884:  INCF   x59,F
0886:  BTFSC  FD8.2
0888:  INCF   x5A,F
088A:  BTFSC  FD8.2
088C:  INCF   x5B,F
088E:  BTFSS  x5F.7
0890:  BRA    08A8
0892:  COMF   x5C,F
0894:  COMF   x5D,F
0896:  COMF   x5E,F
0898:  COMF   x5F,F
089A:  INCF   x5C,F
089C:  BTFSC  FD8.2
089E:  INCF   x5D,F
08A0:  BTFSC  FD8.2
08A2:  INCF   x5E,F
08A4:  BTFSC  FD8.2
08A6:  INCF   x5F,F
08A8:  CLRF   00
08AA:  CLRF   01
08AC:  CLRF   02
08AE:  CLRF   03
08B0:  CLRF   x60
08B2:  CLRF   x61
08B4:  CLRF   x62
08B6:  CLRF   x63
08B8:  MOVF   x5F,W
08BA:  IORWF  x5E,W
08BC:  IORWF  x5D,W
08BE:  IORWF  x5C,W
08C0:  BZ    091A
08C2:  MOVLW  20
08C4:  MOVWF  x64
08C6:  BCF    FD8.0
08C8:  RLCF   x58,F
08CA:  RLCF   x59,F
08CC:  RLCF   x5A,F
08CE:  RLCF   x5B,F
08D0:  RLCF   x60,F
08D2:  RLCF   x61,F
08D4:  RLCF   x62,F
08D6:  RLCF   x63,F
08D8:  MOVF   x5F,W
08DA:  SUBWF  x63,W
08DC:  BNZ   08EE
08DE:  MOVF   x5E,W
08E0:  SUBWF  x62,W
08E2:  BNZ   08EE
08E4:  MOVF   x5D,W
08E6:  SUBWF  x61,W
08E8:  BNZ   08EE
08EA:  MOVF   x5C,W
08EC:  SUBWF  x60,W
08EE:  BNC   090E
08F0:  MOVF   x5C,W
08F2:  SUBWF  x60,F
08F4:  MOVF   x5D,W
08F6:  BTFSS  FD8.0
08F8:  INCFSZ x5D,W
08FA:  SUBWF  x61,F
08FC:  MOVF   x5E,W
08FE:  BTFSS  FD8.0
0900:  INCFSZ x5E,W
0902:  SUBWF  x62,F
0904:  MOVF   x5F,W
0906:  BTFSS  FD8.0
0908:  INCFSZ x5F,W
090A:  SUBWF  x63,F
090C:  BSF    FD8.0
090E:  RLCF   00,F
0910:  RLCF   01,F
0912:  RLCF   02,F
0914:  RLCF   03,F
0916:  DECFSZ x64,F
0918:  BRA    08C6
091A:  BTFSS  x65.7
091C:  BRA    0934
091E:  COMF   00,F
0920:  COMF   01,F
0922:  COMF   02,F
0924:  COMF   03,F
0926:  INCF   00,F
0928:  BTFSC  FD8.2
092A:  INCF   01,F
092C:  BTFSC  FD8.2
092E:  INCF   02,F
0930:  BTFSC  FD8.2
0932:  INCF   03,F
0934:  MOVFF  160,FEF
0938:  MOVFF  161,FEC
093C:  MOVFF  162,FEC
0940:  MOVFF  163,FEC
0944:  MOVLB  0
0946:  RETURN 0
*
0E24:  MOVLB  1
0E26:  MOVF   x4A,W
0E28:  MULWF  x4C
0E2A:  MOVFF  FF3,01
0E2E:  MOVFF  FF4,00
0E32:  MULWF  x4D
0E34:  MOVF   FF3,W
0E36:  ADDWF  00,F
0E38:  MOVF   x4B,W
0E3A:  MULWF  x4C
0E3C:  MOVF   FF3,W
0E3E:  ADDWFC 00,W
0E40:  MOVWF  02
0E42:  MOVLB  0
0E44:  GOTO   120E (RETURN)
*
12C4:  MOVF   FEF,F
12C6:  BZ    12E8
12C8:  MOVFF  FEA,142
12CC:  MOVFF  FE9,141
12D0:  MOVFF  FEF,14E
12D4:  CALL   0282
12D8:  MOVFF  142,FEA
12DC:  MOVFF  141,FE9
12E0:  INCF   FE9,F
12E2:  BTFSC  FD8.2
12E4:  INCF   FEA,F
12E6:  BRA    12C4
12E8:  RETURN 0
12EA:  MOVLB  1
12EC:  MOVF   x89,W
12EE:  BTFSC  FD8.2
12F0:  BRA    13D4
12F2:  MOVWF  00
12F4:  MOVF   x8D,W
12F6:  BTFSC  FD8.2
12F8:  BRA    13D4
12FA:  ADDWF  00,F
12FC:  BNC   1306
12FE:  MOVLW  81
1300:  ADDWF  00,F
1302:  BC    13D4
1304:  BRA    130E
1306:  MOVLW  7F
1308:  SUBWF  00,F
130A:  BNC   13D4
130C:  BZ    13D4
130E:  MOVFF  18A,191
1312:  MOVF   x8E,W
1314:  XORWF  x91,F
1316:  BSF    x8A.7
1318:  BSF    x8E.7
131A:  MOVF   x8C,W
131C:  MULWF  x90
131E:  MOVFF  FF4,193
1322:  MOVF   x8B,W
1324:  MULWF  x8F
1326:  MOVFF  FF4,03
132A:  MOVFF  FF3,192
132E:  MULWF  x90
1330:  MOVF   FF3,W
1332:  ADDWF  x93,F
1334:  MOVF   FF4,W
1336:  ADDWFC x92,F
1338:  MOVLW  00
133A:  ADDWFC 03,F
133C:  MOVF   x8C,W
133E:  MULWF  x8F
1340:  MOVF   FF3,W
1342:  ADDWF  x93,F
1344:  MOVF   FF4,W
1346:  ADDWFC x92,F
1348:  MOVLW  00
134A:  CLRF   02
134C:  ADDWFC 03,F
134E:  ADDWFC 02,F
1350:  MOVF   x8A,W
1352:  MULWF  x90
1354:  MOVF   FF3,W
1356:  ADDWF  x92,F
1358:  MOVF   FF4,W
135A:  ADDWFC 03,F
135C:  MOVLW  00
135E:  ADDWFC 02,F
1360:  MOVF   x8A,W
1362:  MULWF  x8F
1364:  MOVF   FF3,W
1366:  ADDWF  03,F
1368:  MOVF   FF4,W
136A:  ADDWFC 02,F
136C:  MOVLW  00
136E:  CLRF   01
1370:  ADDWFC 01,F
1372:  MOVF   x8C,W
1374:  MULWF  x8E
1376:  MOVF   FF3,W
1378:  ADDWF  x92,F
137A:  MOVF   FF4,W
137C:  ADDWFC 03,F
137E:  MOVLW  00
1380:  ADDWFC 02,F
1382:  ADDWFC 01,F
1384:  MOVF   x8B,W
1386:  MULWF  x8E
1388:  MOVF   FF3,W
138A:  ADDWF  03,F
138C:  MOVF   FF4,W
138E:  ADDWFC 02,F
1390:  MOVLW  00
1392:  ADDWFC 01,F
1394:  MOVF   x8A,W
1396:  MULWF  x8E
1398:  MOVF   FF3,W
139A:  ADDWF  02,F
139C:  MOVF   FF4,W
139E:  ADDWFC 01,F
13A0:  INCF   00,F
13A2:  BTFSC  01.7
13A4:  BRA    13B0
13A6:  RLCF   x92,F
13A8:  RLCF   03,F
13AA:  RLCF   02,F
13AC:  RLCF   01,F
13AE:  DECF   00,F
13B0:  MOVLW  00
13B2:  BTFSS  x92.7
13B4:  BRA    13CA
13B6:  INCF   03,F
13B8:  ADDWFC 02,F
13BA:  ADDWFC 01,F
13BC:  MOVF   01,W
13BE:  BNZ   13CA
13C0:  MOVF   02,W
13C2:  BNZ   13CA
13C4:  MOVF   03,W
13C6:  BNZ   13CA
13C8:  INCF   00,F
13CA:  BTFSC  x91.7
13CC:  BSF    01.7
13CE:  BTFSS  x91.7
13D0:  BCF    01.7
13D2:  BRA    13DC
13D4:  CLRF   00
13D6:  CLRF   01
13D8:  CLRF   02
13DA:  CLRF   03
13DC:  MOVLB  0
13DE:  RETURN 0
13E0:  MOVLW  8E
13E2:  MOVWF  00
13E4:  MOVFF  18A,01
13E8:  MOVFF  189,02
13EC:  CLRF   03
13EE:  MOVF   01,F
13F0:  BNZ   1404
13F2:  MOVFF  02,01
13F6:  CLRF   02
13F8:  MOVLW  08
13FA:  SUBWF  00,F
13FC:  MOVF   01,F
13FE:  BNZ   1404
1400:  CLRF   00
1402:  BRA    1414
1404:  BCF    FD8.0
1406:  BTFSC  01.7
1408:  BRA    1412
140A:  RLCF   02,F
140C:  RLCF   01,F
140E:  DECF   00,F
1410:  BRA    1404
1412:  BCF    01.7
1414:  RETURN 0
1416:  MOVLB  1
1418:  MOVF   x75,W
141A:  BTFSC  FD8.2
141C:  BRA    1568
141E:  MOVWF  x81
1420:  MOVF   x79,W
1422:  BTFSC  FD8.2
1424:  BRA    1568
1426:  SUBWF  x81,F
1428:  BNC   1434
142A:  MOVLW  7F
142C:  ADDWF  x81,F
142E:  BTFSC  FD8.0
1430:  BRA    1568
1432:  BRA    1440
1434:  MOVLW  81
1436:  SUBWF  x81,F
1438:  BTFSS  FD8.0
143A:  BRA    1568
143C:  BTFSC  FD8.2
143E:  BRA    1568
1440:  MOVFF  181,00
1444:  CLRF   01
1446:  CLRF   02
1448:  CLRF   03
144A:  CLRF   x80
144C:  MOVFF  176,17F
1450:  BSF    x7F.7
1452:  MOVFF  177,17E
1456:  MOVFF  178,17D
145A:  MOVLW  19
145C:  MOVWF  x81
145E:  MOVF   x7C,W
1460:  SUBWF  x7D,F
1462:  BC    147E
1464:  MOVLW  01
1466:  SUBWF  x7E,F
1468:  BC    147E
146A:  SUBWF  x7F,F
146C:  BC    147E
146E:  SUBWF  x80,F
1470:  BC    147E
1472:  INCF   x80,F
1474:  INCF   x7F,F
1476:  INCF   x7E,F
1478:  MOVF   x7C,W
147A:  ADDWF  x7D,F
147C:  BRA    14CE
147E:  MOVF   x7B,W
1480:  SUBWF  x7E,F
1482:  BC    14A8
1484:  MOVLW  01
1486:  SUBWF  x7F,F
1488:  BC    14A8
148A:  SUBWF  x80,F
148C:  BC    14A8
148E:  INCF   x80,F
1490:  INCF   x7F,F
1492:  MOVF   x7B,W
1494:  ADDWF  x7E,F
1496:  MOVF   x7C,W
1498:  ADDWF  x7D,F
149A:  BNC   14CE
149C:  INCF   x7E,F
149E:  BNZ   14CE
14A0:  INCF   x7F,F
14A2:  BNZ   14CE
14A4:  INCF   x80,F
14A6:  BRA    14CE
14A8:  MOVF   x7A,W
14AA:  IORLW  80
14AC:  SUBWF  x7F,F
14AE:  BC    14CC
14B0:  MOVLW  01
14B2:  SUBWF  x80,F
14B4:  BC    14CC
14B6:  INCF   x80,F
14B8:  MOVF   x7A,W
14BA:  IORLW  80
14BC:  ADDWF  x7F,F
14BE:  MOVF   x7B,W
14C0:  ADDWF  x7E,F
14C2:  BNC   1496
14C4:  INCF   x7F,F
14C6:  BNZ   1496
14C8:  INCF   x80,F
14CA:  BRA    1496
14CC:  BSF    03.0
14CE:  DECFSZ x81,F
14D0:  BRA    14D4
14D2:  BRA    14EA
14D4:  BCF    FD8.0
14D6:  RLCF   x7D,F
14D8:  RLCF   x7E,F
14DA:  RLCF   x7F,F
14DC:  RLCF   x80,F
14DE:  BCF    FD8.0
14E0:  RLCF   03,F
14E2:  RLCF   02,F
14E4:  RLCF   01,F
14E6:  RLCF   x82,F
14E8:  BRA    145E
14EA:  BTFSS  x82.0
14EC:  BRA    14FA
14EE:  BCF    FD8.0
14F0:  RRCF   01,F
14F2:  RRCF   02,F
14F4:  RRCF   03,F
14F6:  RRCF   x82,F
14F8:  BRA    14FE
14FA:  DECF   00,F
14FC:  BZ    1568
14FE:  BTFSC  x82.7
1500:  BRA    153E
1502:  BCF    FD8.0
1504:  RLCF   x7D,F
1506:  RLCF   x7E,F
1508:  RLCF   x7F,F
150A:  RLCF   x80,F
150C:  MOVF   x7C,W
150E:  SUBWF  x7D,F
1510:  BC    1520
1512:  MOVLW  01
1514:  SUBWF  x7E,F
1516:  BC    1520
1518:  SUBWF  x7F,F
151A:  BC    1520
151C:  SUBWF  x80,F
151E:  BNC   1554
1520:  MOVF   x7B,W
1522:  SUBWF  x7E,F
1524:  BC    1530
1526:  MOVLW  01
1528:  SUBWF  x7F,F
152A:  BC    1530
152C:  SUBWF  x80,F
152E:  BNC   1554
1530:  MOVF   x7A,W
1532:  IORLW  80
1534:  SUBWF  x7F,F
1536:  BC    153E
1538:  MOVLW  01
153A:  SUBWF  x80,F
153C:  BNC   1554
153E:  INCF   03,F
1540:  BNZ   1554
1542:  INCF   02,F
1544:  BNZ   1554
1546:  INCF   01,F
1548:  BNZ   1554
154A:  INCF   00,F
154C:  BZ    1568
154E:  RRCF   01,F
1550:  RRCF   02,F
1552:  RRCF   03,F
1554:  MOVFF  176,181
1558:  MOVF   x7A,W
155A:  XORWF  x81,F
155C:  BTFSS  x81.7
155E:  BRA    1564
1560:  BSF    01.7
1562:  BRA    1570
1564:  BCF    01.7
1566:  BRA    1570
1568:  CLRF   00
156A:  CLRF   01
156C:  CLRF   02
156E:  CLRF   03
1570:  MOVLB  0
1572:  RETURN 0
1574:  MOVLW  80
1576:  BTFSS  FD8.1
1578:  BRA    157E
157A:  MOVLB  1
157C:  XORWF  x8E,F
157E:  MOVLB  1
1580:  CLRF   x93
1582:  CLRF   x94
1584:  MOVFF  18A,192
1588:  MOVF   x8E,W
158A:  XORWF  x92,F
158C:  MOVF   x89,W
158E:  BTFSC  FD8.2
1590:  BRA    1750
1592:  MOVWF  x91
1594:  MOVWF  00
1596:  MOVF   x8D,W
1598:  BTFSC  FD8.2
159A:  BRA    1762
159C:  SUBWF  x91,F
159E:  BTFSC  FD8.2
15A0:  BRA    16A8
15A2:  BNC   1620
15A4:  MOVFF  18E,197
15A8:  BSF    x97.7
15AA:  MOVFF  18F,196
15AE:  MOVFF  190,195
15B2:  CLRF   x94
15B4:  BCF    FD8.0
15B6:  RRCF   x97,F
15B8:  RRCF   x96,F
15BA:  RRCF   x95,F
15BC:  RRCF   x94,F
15BE:  DECFSZ x91,F
15C0:  BRA    15B2
15C2:  BTFSS  x92.7
15C4:  BRA    15CC
15C6:  BSF    x93.0
15C8:  BRA    178A
15CA:  BCF    x93.0
15CC:  BCF    x91.0
15CE:  BSF    x93.4
15D0:  MOVLW  01
15D2:  MOVWF  FEA
15D4:  MOVLW  8C
15D6:  MOVWF  FE9
15D8:  BRA    17B0
15DA:  BCF    x93.4
15DC:  BTFSC  x92.7
15DE:  BRA    15F4
15E0:  BTFSS  x91.0
15E2:  BRA    160A
15E4:  RRCF   x97,F
15E6:  RRCF   x96,F
15E8:  RRCF   x95,F
15EA:  RRCF   x94,F
15EC:  INCF   00,F
15EE:  BTFSC  FD8.2
15F0:  BRA    1780
15F2:  BRA    160A
15F4:  BTFSC  x97.7
15F6:  BRA    1610
15F8:  BCF    FD8.0
15FA:  RLCF   x94,F
15FC:  RLCF   x95,F
15FE:  RLCF   x96,F
1600:  RLCF   x97,F
1602:  DECF   00,F
1604:  BTFSC  FD8.2
1606:  BRA    1780
1608:  BRA    15F4
160A:  BSF    x93.6
160C:  BRA    16E8
160E:  BCF    x93.6
1610:  MOVFF  18A,192
1614:  BTFSS  x8A.7
1616:  BRA    161C
1618:  BSF    x97.7
161A:  BRA    1772
161C:  BCF    x97.7
161E:  BRA    1772
1620:  MOVFF  18D,191
1624:  MOVFF  18D,00
1628:  MOVF   x89,W
162A:  SUBWF  x91,F
162C:  MOVFF  18A,197
1630:  BSF    x97.7
1632:  MOVFF  18B,196
1636:  MOVFF  18C,195
163A:  CLRF   x94
163C:  BCF    FD8.0
163E:  RRCF   x97,F
1640:  RRCF   x96,F
1642:  RRCF   x95,F
1644:  RRCF   x94,F
1646:  DECFSZ x91,F
1648:  BRA    163A
164A:  BTFSS  x92.7
164C:  BRA    1654
164E:  BSF    x93.1
1650:  BRA    178A
1652:  BCF    x93.1
1654:  BCF    x91.0
1656:  BSF    x93.5
1658:  MOVLW  01
165A:  MOVWF  FEA
165C:  MOVLW  90
165E:  MOVWF  FE9
1660:  BRA    17B0
1662:  BCF    x93.5
1664:  BTFSC  x92.7
1666:  BRA    167C
1668:  BTFSS  x91.0
166A:  BRA    1692
166C:  RRCF   x97,F
166E:  RRCF   x96,F
1670:  RRCF   x95,F
1672:  RRCF   x94,F
1674:  INCF   00,F
1676:  BTFSC  FD8.2
1678:  BRA    1780
167A:  BRA    1692
167C:  BTFSC  x97.7
167E:  BRA    1698
1680:  BCF    FD8.0
1682:  RLCF   x94,F
1684:  RLCF   x95,F
1686:  RLCF   x96,F
1688:  RLCF   x97,F
168A:  DECF   00,F
168C:  BTFSC  FD8.2
168E:  BRA    1780
1690:  BRA    167C
1692:  BSF    x93.7
1694:  BRA    16E8
1696:  BCF    x93.7
1698:  MOVFF  18E,192
169C:  BTFSS  x8E.7
169E:  BRA    16A4
16A0:  BSF    x97.7
16A2:  BRA    1772
16A4:  BCF    x97.7
16A6:  BRA    1772
16A8:  MOVFF  18E,197
16AC:  BSF    x97.7
16AE:  MOVFF  18F,196
16B2:  MOVFF  190,195
16B6:  BTFSS  x92.7
16B8:  BRA    16C2
16BA:  BCF    x97.7
16BC:  BSF    x93.2
16BE:  BRA    178A
16C0:  BCF    x93.2
16C2:  CLRF   x94
16C4:  BCF    x91.0
16C6:  MOVLW  01
16C8:  MOVWF  FEA
16CA:  MOVLW  8C
16CC:  MOVWF  FE9
16CE:  BRA    17B0
16D0:  BTFSC  x92.7
16D2:  BRA    170C
16D4:  MOVFF  18A,192
16D8:  BTFSS  x91.0
16DA:  BRA    16E8
16DC:  RRCF   x97,F
16DE:  RRCF   x96,F
16E0:  RRCF   x95,F
16E2:  RRCF   x94,F
16E4:  INCF   00,F
16E6:  BZ    1780
16E8:  BTFSS  x94.7
16EA:  BRA    1702
16EC:  INCF   x95,F
16EE:  BNZ   1702
16F0:  INCF   x96,F
16F2:  BNZ   1702
16F4:  INCF   x97,F
16F6:  BNZ   1702
16F8:  RRCF   x97,F
16FA:  RRCF   x96,F
16FC:  RRCF   x95,F
16FE:  INCF   00,F
1700:  BZ    1780
1702:  BTFSC  x93.6
1704:  BRA    160E
1706:  BTFSC  x93.7
1708:  BRA    1696
170A:  BRA    1744
170C:  MOVLW  80
170E:  XORWF  x97,F
1710:  BTFSS  x97.7
1712:  BRA    171C
1714:  BRA    178A
1716:  MOVFF  18E,192
171A:  BRA    1730
171C:  MOVFF  18A,192
1720:  MOVF   x97,F
1722:  BNZ   1730
1724:  MOVF   x96,F
1726:  BNZ   1730
1728:  MOVF   x95,F
172A:  BNZ   1730
172C:  CLRF   00
172E:  BRA    1772
1730:  BTFSC  x97.7
1732:  BRA    1744
1734:  BCF    FD8.0
1736:  RLCF   x94,F
1738:  RLCF   x95,F
173A:  RLCF   x96,F
173C:  RLCF   x97,F
173E:  DECFSZ 00,F
1740:  BRA    1730
1742:  BRA    1780
1744:  BTFSS  x92.7
1746:  BRA    174C
1748:  BSF    x97.7
174A:  BRA    1772
174C:  BCF    x97.7
174E:  BRA    1772
1750:  MOVFF  18D,00
1754:  MOVFF  18E,197
1758:  MOVFF  18F,196
175C:  MOVFF  190,195
1760:  BRA    1772
1762:  MOVFF  189,00
1766:  MOVFF  18A,197
176A:  MOVFF  18B,196
176E:  MOVFF  18C,195
1772:  MOVFF  197,01
1776:  MOVFF  196,02
177A:  MOVFF  195,03
177E:  BRA    17E8
1780:  CLRF   00
1782:  CLRF   01
1784:  CLRF   02
1786:  CLRF   03
1788:  BRA    17E8
178A:  CLRF   x94
178C:  COMF   x95,F
178E:  COMF   x96,F
1790:  COMF   x97,F
1792:  COMF   x94,F
1794:  INCF   x94,F
1796:  BNZ   17A2
1798:  INCF   x95,F
179A:  BNZ   17A2
179C:  INCF   x96,F
179E:  BNZ   17A2
17A0:  INCF   x97,F
17A2:  BTFSC  x93.0
17A4:  BRA    15CA
17A6:  BTFSC  x93.1
17A8:  BRA    1652
17AA:  BTFSC  x93.2
17AC:  BRA    16C0
17AE:  BRA    1716
17B0:  MOVF   FEF,W
17B2:  ADDWF  x95,F
17B4:  BNC   17C0
17B6:  INCF   x96,F
17B8:  BNZ   17C0
17BA:  INCF   x97,F
17BC:  BTFSC  FD8.2
17BE:  BSF    x91.0
17C0:  MOVF   FED,F
17C2:  MOVF   FEF,W
17C4:  ADDWF  x96,F
17C6:  BNC   17CE
17C8:  INCF   x97,F
17CA:  BTFSC  FD8.2
17CC:  BSF    x91.0
17CE:  MOVF   FED,F
17D0:  MOVF   FEF,W
17D2:  BTFSC  FEF.7
17D4:  BRA    17D8
17D6:  XORLW  80
17D8:  ADDWF  x97,F
17DA:  BTFSC  FD8.0
17DC:  BSF    x91.0
17DE:  BTFSC  x93.4
17E0:  BRA    15DA
17E2:  BTFSC  x93.5
17E4:  BRA    1662
17E6:  BRA    16D0
17E8:  MOVLB  0
17EA:  RETURN 0
*
1A3A:  MOVFF  186,18D
1A3E:  MOVLB  1
1A40:  MOVF   x8A,W
1A42:  XORWF  x8D,F
1A44:  BTFSS  x8D.7
1A46:  BRA    1A52
1A48:  BCF    FD8.2
1A4A:  BCF    FD8.0
1A4C:  BTFSC  x86.7
1A4E:  BSF    FD8.0
1A50:  BRA    1AB0
1A52:  MOVFF  186,18D
1A56:  MOVFF  189,18E
1A5A:  MOVF   x85,W
1A5C:  SUBWF  x8E,F
1A5E:  BZ    1A6C
1A60:  BTFSS  x8D.7
1A62:  BRA    1AB0
1A64:  MOVF   FD8,W
1A66:  XORLW  01
1A68:  MOVWF  FD8
1A6A:  BRA    1AB0
1A6C:  MOVFF  18A,18E
1A70:  MOVF   x86,W
1A72:  SUBWF  x8E,F
1A74:  BZ    1A82
1A76:  BTFSS  x8D.7
1A78:  BRA    1AB0
1A7A:  MOVF   FD8,W
1A7C:  XORLW  01
1A7E:  MOVWF  FD8
1A80:  BRA    1AB0
1A82:  MOVFF  18B,18E
1A86:  MOVF   x87,W
1A88:  SUBWF  x8E,F
1A8A:  BZ    1A98
1A8C:  BTFSS  x8D.7
1A8E:  BRA    1AB0
1A90:  MOVF   FD8,W
1A92:  XORLW  01
1A94:  MOVWF  FD8
1A96:  BRA    1AB0
1A98:  MOVFF  18C,18E
1A9C:  MOVF   x88,W
1A9E:  SUBWF  x8E,F
1AA0:  BZ    1AAE
1AA2:  BTFSS  x8D.7
1AA4:  BRA    1AB0
1AA6:  MOVF   FD8,W
1AA8:  XORLW  01
1AAA:  MOVWF  FD8
1AAC:  BRA    1AB0
1AAE:  BCF    FD8.0
1AB0:  MOVLB  0
1AB2:  RETURN 0
1AB4:  MOVLW  8E
1AB6:  MOVWF  00
1AB8:  MOVLB  1
1ABA:  MOVF   x85,W
1ABC:  SUBWF  00,F
1ABE:  MOVFF  186,02
1AC2:  MOVFF  187,01
1AC6:  BSF    02.7
1AC8:  MOVF   00,F
1ACA:  BZ    1ADE
1ACC:  BCF    FD8.0
1ACE:  MOVF   02,F
1AD0:  BNZ   1AD6
1AD2:  MOVF   01,F
1AD4:  BZ    1ADE
1AD6:  RRCF   02,F
1AD8:  RRCF   01,F
1ADA:  DECFSZ 00,F
1ADC:  BRA    1ACC
1ADE:  BTFSS  x86.7
1AE0:  BRA    1AEC
1AE2:  COMF   01,F
1AE4:  COMF   02,F
1AE6:  INCF   01,F
1AE8:  BTFSC  FD8.2
1AEA:  INCF   02,F
1AEC:  MOVLB  0
1AEE:  RETURN 0
*
285E:  TBLRD*+
2860:  MOVFF  FF6,142
2864:  MOVFF  FF7,143
2868:  MOVFF  FF5,14E
286C:  CALL   0282
2870:  MOVFF  142,FF6
2874:  MOVFF  143,FF7
2878:  MOVLB  1
287A:  DECFSZ x41,F
287C:  BRA    2880
287E:  BRA    2884
2880:  MOVLB  0
2882:  BRA    285E
2884:  MOVLB  0
2886:  RETURN 0
2888:  MOVLB  1
288A:  MOVF   x4E,W
288C:  SUBLW  B6
288E:  MOVWF  x4E
2890:  CLRF   03
2892:  MOVFF  14F,152
2896:  BSF    x4F.7
2898:  BCF    FD8.0
289A:  RRCF   x4F,F
289C:  RRCF   x50,F
289E:  RRCF   x51,F
28A0:  RRCF   03,F
28A2:  RRCF   02,F
28A4:  RRCF   01,F
28A6:  RRCF   00,F
28A8:  DECFSZ x4E,F
28AA:  BRA    2898
28AC:  BTFSS  x52.7
28AE:  BRA    28C6
28B0:  COMF   00,F
28B2:  COMF   01,F
28B4:  COMF   02,F
28B6:  COMF   03,F
28B8:  INCF   00,F
28BA:  BTFSC  FD8.2
28BC:  INCF   01,F
28BE:  BTFSC  FD8.2
28C0:  INCF   02,F
28C2:  BTFSC  FD8.2
28C4:  INCF   03,F
28C6:  MOVLB  0
28C8:  GOTO   29B8 (RETURN)
28CC:  BTFSC  FD8.1
28CE:  BRA    28D8
28D0:  MOVLW  01
28D2:  MOVWF  FEA
28D4:  MOVLW  56
28D6:  MOVWF  FE9
28D8:  CLRF   00
28DA:  CLRF   01
28DC:  CLRF   02
28DE:  CLRF   03
28E0:  MOVLB  1
28E2:  CLRF   x56
28E4:  CLRF   x57
28E6:  CLRF   x58
28E8:  CLRF   x59
28EA:  MOVF   x55,W
28EC:  IORWF  x54,W
28EE:  IORWF  x53,W
28F0:  IORWF  x52,W
28F2:  BZ    294C
28F4:  MOVLW  20
28F6:  MOVWF  x5A
28F8:  BCF    FD8.0
28FA:  RLCF   x4E,F
28FC:  RLCF   x4F,F
28FE:  RLCF   x50,F
2900:  RLCF   x51,F
2902:  RLCF   x56,F
2904:  RLCF   x57,F
2906:  RLCF   x58,F
2908:  RLCF   x59,F
290A:  MOVF   x55,W
290C:  SUBWF  x59,W
290E:  BNZ   2920
2910:  MOVF   x54,W
2912:  SUBWF  x58,W
2914:  BNZ   2920
2916:  MOVF   x53,W
2918:  SUBWF  x57,W
291A:  BNZ   2920
291C:  MOVF   x52,W
291E:  SUBWF  x56,W
2920:  BNC   2940
2922:  MOVF   x52,W
2924:  SUBWF  x56,F
2926:  MOVF   x53,W
2928:  BTFSS  FD8.0
292A:  INCFSZ x53,W
292C:  SUBWF  x57,F
292E:  MOVF   x54,W
2930:  BTFSS  FD8.0
2932:  INCFSZ x54,W
2934:  SUBWF  x58,F
2936:  MOVF   x55,W
2938:  BTFSS  FD8.0
293A:  INCFSZ x55,W
293C:  SUBWF  x59,F
293E:  BSF    FD8.0
2940:  RLCF   00,F
2942:  RLCF   01,F
2944:  RLCF   02,F
2946:  RLCF   03,F
2948:  DECFSZ x5A,F
294A:  BRA    28F8
294C:  MOVFF  156,FEF
2950:  MOVFF  157,FEC
2954:  MOVFF  158,FEC
2958:  MOVFF  159,FEC
295C:  MOVLB  0
295E:  RETURN 0
2960:  MOVF   FE9,W
2962:  MOVLB  1
2964:  MOVWF  x46
2966:  MOVF   x45,W
2968:  MOVWF  x48
296A:  BZ    29A4
296C:  MOVFF  144,18C
2970:  MOVFF  143,18B
2974:  MOVFF  142,18A
2978:  MOVFF  141,189
297C:  CLRF   x90
297E:  CLRF   x8F
2980:  MOVLW  20
2982:  MOVWF  x8E
2984:  MOVLW  82
2986:  MOVWF  x8D
2988:  MOVLB  0
298A:  CALL   12EA
298E:  MOVFF  03,144
2992:  MOVFF  02,143
2996:  MOVFF  01,142
299A:  MOVFF  00,141
299E:  MOVLB  1
29A0:  DECFSZ x48,F
29A2:  BRA    296C
29A4:  MOVFF  144,151
29A8:  MOVFF  143,150
29AC:  MOVFF  142,14F
29B0:  MOVFF  141,14E
29B4:  MOVLB  0
29B6:  BRA    2888
29B8:  MOVFF  03,144
29BC:  MOVFF  02,143
29C0:  MOVFF  01,142
29C4:  MOVFF  00,141
29C8:  MOVLB  1
29CA:  BTFSS  x44.7
29CC:  BRA    29E8
29CE:  DECF   x46,F
29D0:  BSF    x46.5
29D2:  COMF   x41,F
29D4:  COMF   x42,F
29D6:  COMF   x43,F
29D8:  COMF   x44,F
29DA:  INCF   x41,F
29DC:  BTFSC  FD8.2
29DE:  INCF   x42,F
29E0:  BTFSC  FD8.2
29E2:  INCF   x43,F
29E4:  BTFSC  FD8.2
29E6:  INCF   x44,F
29E8:  MOVLW  3B
29EA:  MOVWF  x4D
29EC:  MOVLW  9A
29EE:  MOVWF  x4C
29F0:  MOVLW  CA
29F2:  MOVWF  x4B
29F4:  CLRF   x4A
29F6:  MOVLW  0A
29F8:  MOVWF  x48
29FA:  MOVF   x45,W
29FC:  BTFSC  FD8.2
29FE:  INCF   x46,F
2A00:  BSF    FD8.1
2A02:  MOVLW  01
2A04:  MOVWF  FEA
2A06:  MOVLW  41
2A08:  MOVWF  FE9
2A0A:  MOVFF  144,151
2A0E:  MOVFF  143,150
2A12:  MOVFF  142,14F
2A16:  MOVFF  141,14E
2A1A:  MOVFF  14D,155
2A1E:  MOVFF  14C,154
2A22:  MOVFF  14B,153
2A26:  MOVFF  14A,152
2A2A:  MOVLB  0
2A2C:  RCALL  28CC
2A2E:  MOVF   01,W
2A30:  MOVF   00,F
2A32:  BNZ   2A5A
2A34:  MOVLB  1
2A36:  INCF   x45,W
2A38:  SUBWF  x48,W
2A3A:  BTFSS  FD8.2
2A3C:  BRA    2A42
2A3E:  MOVLB  0
2A40:  BRA    2A5A
2A42:  MOVF   x46,W
2A44:  BZ    2A60
2A46:  ANDLW  0F
2A48:  SUBWF  x48,W
2A4A:  BZ    2A4E
2A4C:  BC    2AD6
2A4E:  BTFSC  x46.7
2A50:  BRA    2AD6
2A52:  BTFSC  x46.6
2A54:  BRA    2A60
2A56:  MOVLW  20
2A58:  BRA    2AC8
2A5A:  MOVLW  20
2A5C:  MOVLB  1
2A5E:  ANDWF  x46,F
2A60:  BTFSS  x46.5
2A62:  BRA    2A82
2A64:  BCF    x46.5
2A66:  MOVF   x45,W
2A68:  BTFSS  FD8.2
2A6A:  DECF   x46,F
2A6C:  MOVF   00,W
2A6E:  MOVWF  x46
2A70:  MOVLW  2D
2A72:  MOVWF  x4E
2A74:  MOVLB  0
2A76:  CALL   0282
2A7A:  MOVLB  1
2A7C:  MOVF   x46,W
2A7E:  MOVWF  00
2A80:  CLRF   x46
2A82:  MOVF   x45,W
2A84:  SUBWF  x48,W
2A86:  BNZ   2AA2
2A88:  MOVF   00,W
2A8A:  MOVWF  x46
2A8C:  MOVLW  2E
2A8E:  MOVWF  x4E
2A90:  MOVLB  0
2A92:  CALL   0282
2A96:  MOVLB  1
2A98:  MOVF   x46,W
2A9A:  MOVWF  00
2A9C:  MOVLW  20
2A9E:  ANDWF  x46,F
2AA0:  MOVLW  00
2AA2:  MOVLW  30
2AA4:  BTFSS  x46.5
2AA6:  BRA    2AC8
2AA8:  BCF    x46.5
2AAA:  MOVF   x45,W
2AAC:  BTFSS  FD8.2
2AAE:  DECF   x46,F
2AB0:  MOVF   00,W
2AB2:  MOVWF  x46
2AB4:  MOVLW  2D
2AB6:  MOVWF  x4E
2AB8:  MOVLB  0
2ABA:  CALL   0282
2ABE:  MOVLB  1
2AC0:  MOVF   x46,W
2AC2:  MOVWF  00
2AC4:  CLRF   x46
2AC6:  MOVLW  30
2AC8:  ADDWF  00,F
2ACA:  MOVFF  00,14E
2ACE:  MOVLB  0
2AD0:  CALL   0282
2AD4:  MOVLB  1
2AD6:  BCF    FD8.1
2AD8:  MOVFF  14D,151
2ADC:  MOVFF  14C,150
2AE0:  MOVFF  14B,14F
2AE4:  MOVFF  14A,14E
2AE8:  CLRF   x55
2AEA:  CLRF   x54
2AEC:  CLRF   x53
2AEE:  MOVLW  0A
2AF0:  MOVWF  x52
2AF2:  MOVLB  0
2AF4:  RCALL  28CC
2AF6:  MOVFF  03,14D
2AFA:  MOVFF  02,14C
2AFE:  MOVFF  01,14B
2B02:  MOVFF  00,14A
2B06:  MOVLB  1
2B08:  DECFSZ x48,F
2B0A:  BRA    2A00
2B0C:  MOVLB  0
2B0E:  RETURN 0
....................  
.................... #list 
....................  
.................... //#include <stdlib.h> 
.................... //#include <stdio.h> 
.................... #device PASS_STRINGS = IN_RAM 
.................... #fuses NOMCLR, INTRC_IO, NOWDT, NOPROTECT, NOLVP 
.................... #use delay(clock = 8MHz) 
*
008A:  MOVLW  01
008C:  MOVWF  FEA
008E:  MOVLW  4F
0090:  MOVWF  FE9
0092:  MOVF   FEF,W
0094:  BZ    00B0
0096:  MOVLW  02
0098:  MOVWF  01
009A:  CLRF   00
009C:  DECFSZ 00,F
009E:  BRA    009C
00A0:  DECFSZ 01,F
00A2:  BRA    009A
00A4:  MOVLW  97
00A6:  MOVWF  00
00A8:  DECFSZ 00,F
00AA:  BRA    00A8
00AC:  DECFSZ FEF,F
00AE:  BRA    0096
00B0:  RETURN 0
.................... #use fast_io(D) 
.................... #use RS232(UART1, BAUD = 9600, ERRORS)   //puerto UART configuracion y iniciow 
*
030E:  BTFSS  F9E.5
0310:  BRA    030E
0312:  MOVFF  FAB,04
0316:  MOVFF  FAE,01
031A:  BTFSS  04.1
031C:  BRA    0322
031E:  BCF    FAB.4
0320:  BSF    FAB.4
0322:  GOTO   03EC (RETURN)
.................... #include <lcd.c>      //incluye libreria LCD  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0138:  BSF    F95.4
....................    output_float(LCD_DATA5); 
013A:  BSF    F95.5
....................    output_float(LCD_DATA6); 
013C:  BSF    F95.6
....................    output_float(LCD_DATA7); 
013E:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0140:  BSF    F8C.1
....................    delay_cycles(1); 
0142:  NOP   
....................    lcd_output_enable(1); 
0144:  BSF    F8C.2
....................    delay_cycles(1); 
0146:  NOP   
....................    high = lcd_read_nibble(); 
0148:  RCALL  00EA
014A:  MOVFF  01,156
....................        
....................    lcd_output_enable(0); 
014E:  BCF    F8C.2
....................    delay_cycles(1); 
0150:  NOP   
....................    lcd_output_enable(1); 
0152:  BSF    F8C.2
....................    delay_us(1); 
0154:  BRA    0156
....................    low = lcd_read_nibble(); 
0156:  RCALL  00EA
0158:  MOVFF  01,155
....................        
....................    lcd_output_enable(0); 
015C:  BCF    F8C.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
015E:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
0160:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
0162:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
0164:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0166:  MOVLB  1
0168:  SWAPF  x56,W
016A:  MOVWF  00
016C:  MOVLW  F0
016E:  ANDWF  00,F
0170:  MOVF   00,W
0172:  IORWF  x55,W
0174:  MOVWF  01
0176:  MOVLB  0
0178:  GOTO   0186 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00EA:  MOVLB  1
00EC:  CLRF   x57
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00EE:  MOVLW  00
00F0:  BTFSC  F83.4
00F2:  MOVLW  01
00F4:  IORWF  x57,F
....................    n |= input(LCD_DATA5) << 1; 
00F6:  MOVLW  00
00F8:  BTFSC  F83.5
00FA:  MOVLW  01
00FC:  MOVWF  00
00FE:  BCF    FD8.0
0100:  RLCF   00,F
0102:  MOVF   00,W
0104:  IORWF  x57,F
....................    n |= input(LCD_DATA6) << 2; 
0106:  MOVLW  00
0108:  BTFSC  F83.6
010A:  MOVLW  01
010C:  MOVWF  00
010E:  RLCF   00,F
0110:  RLCF   00,F
0112:  MOVLW  FC
0114:  ANDWF  00,F
0116:  MOVF   00,W
0118:  IORWF  x57,F
....................    n |= input(LCD_DATA7) << 3; 
011A:  MOVLW  00
011C:  BTFSC  F83.7
011E:  MOVLW  01
0120:  MOVWF  00
0122:  RLCF   00,F
0124:  RLCF   00,F
0126:  RLCF   00,F
0128:  MOVLW  F8
012A:  ANDWF  00,F
012C:  MOVF   00,W
012E:  IORWF  x57,F
....................     
....................    return(n); 
0130:  MOVFF  157,01
....................   #else 
0134:  MOVLB  0
0136:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00B2:  MOVLB  1
00B4:  BTFSC  x56.0
00B6:  BRA    00BC
00B8:  BCF    F8C.4
00BA:  BRA    00BE
00BC:  BSF    F8C.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00BE:  BTFSC  x56.1
00C0:  BRA    00C6
00C2:  BCF    F8C.5
00C4:  BRA    00C8
00C6:  BSF    F8C.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00C8:  BTFSC  x56.2
00CA:  BRA    00D0
00CC:  BCF    F8C.6
00CE:  BRA    00D2
00D0:  BSF    F8C.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00D2:  BTFSC  x56.3
00D4:  BRA    00DA
00D6:  BCF    F8C.7
00D8:  BRA    00DC
00DA:  BSF    F8C.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00DC:  NOP   
....................    lcd_output_enable(1); 
00DE:  BSF    F8C.2
....................    delay_us(2); 
00E0:  BRA    00E2
00E2:  BRA    00E4
....................    lcd_output_enable(0); 
00E4:  BCF    F8C.2
00E6:  MOVLB  0
00E8:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
017C:  BCF    F95.2
....................    lcd_rs_tris(); 
017E:  BCF    F95.0
....................    lcd_rw_tris(); 
0180:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0182:  BCF    F8C.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0184:  BRA    0138
0186:  MOVFF  01,155
018A:  MOVLB  1
018C:  BTFSS  01.7
018E:  BRA    0194
0190:  MOVLB  0
0192:  BRA    0184
....................    lcd_output_rs(address); 
0194:  MOVF   x53,F
0196:  BNZ   019C
0198:  BCF    F8C.0
019A:  BRA    019E
019C:  BSF    F8C.0
....................    delay_cycles(1); 
019E:  NOP   
....................    lcd_output_rw(0); 
01A0:  BCF    F8C.1
....................    delay_cycles(1); 
01A2:  NOP   
....................    lcd_output_enable(0); 
01A4:  BCF    F8C.2
....................    lcd_send_nibble(n >> 4); 
01A6:  SWAPF  x54,W
01A8:  MOVWF  x55
01AA:  MOVLW  0F
01AC:  ANDWF  x55,F
01AE:  MOVFF  155,156
01B2:  MOVLB  0
01B4:  RCALL  00B2
....................    lcd_send_nibble(n & 0xf); 
01B6:  MOVLB  1
01B8:  MOVF   x54,W
01BA:  ANDLW  0F
01BC:  MOVWF  x55
01BE:  MOVWF  x56
01C0:  MOVLB  0
01C2:  RCALL  00B2
01C4:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01C6:  MOVLW  28
01C8:  MOVLB  1
01CA:  MOVWF  x42
01CC:  MOVLW  0C
01CE:  MOVWF  x43
01D0:  MOVLW  01
01D2:  MOVWF  x44
01D4:  MOVLW  06
01D6:  MOVWF  x45
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01D8:  BCF    F8C.2
....................    lcd_output_rs(0); 
01DA:  BCF    F8C.0
....................    lcd_output_rw(0); 
01DC:  BCF    F8C.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01DE:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
01E0:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
01E2:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
01E4:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01E6:  BCF    F95.2
....................    lcd_rs_tris(); 
01E8:  BCF    F95.0
....................    lcd_rw_tris(); 
01EA:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
01EC:  MOVLW  0F
01EE:  MOVWF  x4F
01F0:  MOVLB  0
01F2:  RCALL  008A
....................    for(i=1;i<=3;++i) 
01F4:  MOVLW  01
01F6:  MOVLB  1
01F8:  MOVWF  x41
01FA:  MOVF   x41,W
01FC:  SUBLW  03
01FE:  BNC   0218
....................    { 
....................        lcd_send_nibble(3); 
0200:  MOVLW  03
0202:  MOVWF  x56
0204:  MOVLB  0
0206:  RCALL  00B2
....................        delay_ms(5); 
0208:  MOVLW  05
020A:  MOVLB  1
020C:  MOVWF  x4F
020E:  MOVLB  0
0210:  RCALL  008A
0212:  MOVLB  1
0214:  INCF   x41,F
0216:  BRA    01FA
....................    } 
....................     
....................    lcd_send_nibble(2); 
0218:  MOVLW  02
021A:  MOVWF  x56
021C:  MOVLB  0
021E:  RCALL  00B2
....................    delay_ms(5); 
0220:  MOVLW  05
0222:  MOVLB  1
0224:  MOVWF  x4F
0226:  MOVLB  0
0228:  RCALL  008A
....................    for(i=0;i<=3;++i) 
022A:  MOVLB  1
022C:  CLRF   x41
022E:  MOVF   x41,W
0230:  SUBLW  03
0232:  BNC   0256
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0234:  CLRF   03
0236:  MOVF   x41,W
0238:  ADDLW  42
023A:  MOVWF  FE9
023C:  MOVLW  01
023E:  ADDWFC 03,W
0240:  MOVWF  FEA
0242:  MOVFF  FEF,146
0246:  CLRF   x53
0248:  MOVFF  146,154
024C:  MOVLB  0
024E:  RCALL  017C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0250:  MOVLB  1
0252:  INCF   x41,F
0254:  BRA    022E
0256:  MOVLB  0
0258:  GOTO   2BE2 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
025C:  MOVLB  1
025E:  DECFSZ x50,W
0260:  BRA    0264
0262:  BRA    026A
....................       address=LCD_LINE_TWO; 
0264:  MOVLW  40
0266:  MOVWF  x51
0268:  BRA    026C
....................    else 
....................       address=0; 
026A:  CLRF   x51
....................       
....................    address+=x-1; 
026C:  MOVLW  01
026E:  SUBWF  x4F,W
0270:  ADDWF  x51,F
....................    lcd_send_byte(0,0x80|address); 
0272:  MOVF   x51,W
0274:  IORLW  80
0276:  MOVWF  x52
0278:  CLRF   x53
027A:  MOVWF  x54
027C:  MOVLB  0
027E:  RCALL  017C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0280:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0282:  MOVLB  1
0284:  MOVF   x4E,W
0286:  XORLW  07
0288:  MOVLB  0
028A:  BZ    029A
028C:  XORLW  0B
028E:  BZ    02A8
0290:  XORLW  06
0292:  BZ    02C0
0294:  XORLW  02
0296:  BZ    02D0
0298:  BRA    02DE
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
029A:  MOVLW  01
029C:  MOVLB  1
029E:  MOVWF  x4F
02A0:  MOVWF  x50
02A2:  MOVLB  0
02A4:  RCALL  025C
02A6:  BRA    02EC
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02A8:  MOVLB  1
02AA:  CLRF   x53
02AC:  MOVLW  01
02AE:  MOVWF  x54
02B0:  MOVLB  0
02B2:  RCALL  017C
....................                      delay_ms(2); 
02B4:  MOVLW  02
02B6:  MOVLB  1
02B8:  MOVWF  x4F
02BA:  MOVLB  0
02BC:  RCALL  008A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02BE:  BRA    02EC
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02C0:  MOVLW  01
02C2:  MOVLB  1
02C4:  MOVWF  x4F
02C6:  MOVLW  02
02C8:  MOVWF  x50
02CA:  MOVLB  0
02CC:  RCALL  025C
02CE:  BRA    02EC
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02D0:  MOVLB  1
02D2:  CLRF   x53
02D4:  MOVLW  10
02D6:  MOVWF  x54
02D8:  MOVLB  0
02DA:  RCALL  017C
02DC:  BRA    02EC
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02DE:  MOVLW  01
02E0:  MOVLB  1
02E2:  MOVWF  x53
02E4:  MOVFF  14E,154
02E8:  MOVLB  0
02EA:  RCALL  017C
....................      #endif 
....................    } 
02EC:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <GPS_Lib.c>  //incluye libreria LCD 
.................... // GPS Library for CCS PIC C compiler 
.................... // http://simple-circuit.com/ 
....................  
....................  
....................  
.................... #define _GPRMC_  1 
.................... #define _GPGGA_  2 
.................... #define _OTHER_  3 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0372:  MOVLB  1
0374:  MOVFF  14A,FE9
0378:  MOVFF  14B,FEA
037C:  MOVFF  FEF,14E
0380:  MOVFF  14D,03
0384:  MOVFF  14C,FE9
0388:  MOVFF  14D,FEA
038C:  MOVF   FEF,W
038E:  SUBWF  x4E,W
0390:  BNZ   03BC
....................       if (*s1 == '\0') 
0392:  MOVFF  14B,03
0396:  MOVFF  14A,FE9
039A:  MOVFF  03,FEA
039E:  MOVF   FEF,F
03A0:  BNZ   03A8
....................          return(0); 
03A2:  MOVLW  00
03A4:  MOVWF  01
03A6:  BRA    03E6
03A8:  MOVFF  14B,03
03AC:  MOVF   x4A,W
03AE:  INCF   x4A,F
03B0:  BTFSC  FD8.2
03B2:  INCF   x4B,F
03B4:  INCF   x4C,F
03B6:  BTFSC  FD8.2
03B8:  INCF   x4D,F
03BA:  BRA    0374
....................    return((*s1 < *s2) ? -1: 1); 
03BC:  MOVFF  14B,03
03C0:  MOVFF  14A,FE9
03C4:  MOVFF  14B,FEA
03C8:  MOVFF  FEF,14E
03CC:  MOVFF  14D,03
03D0:  MOVFF  14C,FE9
03D4:  MOVFF  14D,FEA
03D8:  MOVF   FEF,W
03DA:  SUBWF  x4E,W
03DC:  BC    03E2
03DE:  MOVLW  FF
03E0:  BRA    03E4
03E2:  MOVLW  01
03E4:  MOVWF  01
03E6:  MOVLB  0
03E8:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
17EC:  MOVLB  1
17EE:  CLRF   x48
17F0:  CLRF   x47
17F2:  CLRF   x46
17F4:  MOVLW  7F
17F6:  MOVWF  x45
17F8:  CLRF   x4C
17FA:  CLRF   x4B
17FC:  CLRF   x4A
17FE:  CLRF   x49
1800:  BSF    x4D.0
1802:  BCF    x4D.1
1804:  BCF    x4D.2
1806:  CLRF   x4F
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
1808:  MOVF   x41,W
180A:  IORWF  x42,W
180C:  BNZ   1818
....................       return 0; 
180E:  CLRF   00
1810:  CLRF   01
1812:  CLRF   02
1814:  CLRF   03
1816:  BRA    1A36
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
1818:  MOVF   x4F,W
181A:  INCF   x4F,F
181C:  CLRF   03
181E:  ADDWF  x41,W
1820:  MOVWF  FE9
1822:  MOVF   x42,W
1824:  ADDWFC 03,W
1826:  MOVWF  FEA
1828:  MOVFF  FEF,14E
182C:  MOVF   x4E,F
182E:  BTFSC  FD8.2
1830:  BRA    19BC
....................    { 
....................       if (skip && !isspace(c)) 
1832:  BTFSS  x4D.0
1834:  BRA    1854
1836:  MOVF   x4E,W
1838:  SUBLW  20
183A:  BZ    1854
....................       { 
....................          skip = 0; 
183C:  BCF    x4D.0
....................          if (c == '+') 
183E:  MOVF   x4E,W
1840:  SUBLW  2B
1842:  BNZ   184A
....................          { 
....................             sign = 0; 
1844:  BCF    x4D.1
....................             continue; 
1846:  BRA    19A2
....................          }             
1848:  BRA    1854
....................          else if (c == '-') 
184A:  MOVF   x4E,W
184C:  SUBLW  2D
184E:  BNZ   1854
....................          { 
....................             sign = 1; 
1850:  BSF    x4D.1
....................             continue; 
1852:  BRA    19A2
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
1854:  BTFSC  x4D.0
1856:  BRA    1866
1858:  MOVF   x4E,W
185A:  SUBLW  2E
185C:  BNZ   1866
185E:  BTFSC  x4D.2
1860:  BRA    1866
....................          point = 1; 
1862:  BSF    x4D.2
1864:  BRA    19A2
....................       else if (!skip && isdigit(c)) 
1866:  BTFSC  x4D.0
1868:  BRA    199C
186A:  MOVF   x4E,W
186C:  SUBLW  2F
186E:  BTFSC  FD8.0
1870:  BRA    199C
1872:  MOVF   x4E,W
1874:  SUBLW  39
1876:  BTFSS  FD8.0
1878:  BRA    199C
....................       { 
....................          c -= '0'; 
187A:  MOVLW  30
187C:  SUBWF  x4E,F
....................          if (point) 
187E:  BTFSS  x4D.2
1880:  BRA    1928
....................          { 
....................             pow10 = pow10 * 10.0; 
1882:  MOVFF  148,18C
1886:  MOVFF  147,18B
188A:  MOVFF  146,18A
188E:  MOVFF  145,189
1892:  CLRF   x90
1894:  CLRF   x8F
1896:  MOVLW  20
1898:  MOVWF  x8E
189A:  MOVLW  82
189C:  MOVWF  x8D
189E:  MOVLB  0
18A0:  RCALL  12EA
18A2:  MOVFF  03,148
18A6:  MOVFF  02,147
18AA:  MOVFF  01,146
18AE:  MOVFF  00,145
....................             result += (float)c / pow10;    
18B2:  MOVLB  1
18B4:  CLRF   x8A
18B6:  MOVFF  14E,189
18BA:  MOVLB  0
18BC:  RCALL  13E0
18BE:  MOVFF  03,153
18C2:  MOVFF  02,152
18C6:  MOVFF  01,151
18CA:  MOVFF  00,150
18CE:  MOVFF  03,178
18D2:  MOVFF  02,177
18D6:  MOVFF  01,176
18DA:  MOVFF  00,175
18DE:  MOVFF  148,17C
18E2:  MOVFF  147,17B
18E6:  MOVFF  146,17A
18EA:  MOVFF  145,179
18EE:  RCALL  1416
18F0:  BCF    FD8.1
18F2:  MOVFF  14C,18C
18F6:  MOVFF  14B,18B
18FA:  MOVFF  14A,18A
18FE:  MOVFF  149,189
1902:  MOVFF  03,190
1906:  MOVFF  02,18F
190A:  MOVFF  01,18E
190E:  MOVFF  00,18D
1912:  RCALL  1574
1914:  MOVFF  03,14C
1918:  MOVFF  02,14B
191C:  MOVFF  01,14A
1920:  MOVFF  00,149
....................          } 
1924:  BRA    1998
1926:  MOVLB  1
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
1928:  CLRF   x8C
192A:  CLRF   x8B
192C:  MOVLW  20
192E:  MOVWF  x8A
1930:  MOVLW  82
1932:  MOVWF  x89
1934:  MOVFF  14C,190
1938:  MOVFF  14B,18F
193C:  MOVFF  14A,18E
1940:  MOVFF  149,18D
1944:  MOVLB  0
1946:  RCALL  12EA
1948:  MOVFF  03,153
194C:  MOVFF  02,152
1950:  MOVFF  01,151
1954:  MOVFF  00,150
1958:  MOVLB  1
195A:  CLRF   x8A
195C:  MOVFF  14E,189
1960:  MOVLB  0
1962:  RCALL  13E0
1964:  BCF    FD8.1
1966:  MOVFF  153,18C
196A:  MOVFF  152,18B
196E:  MOVFF  151,18A
1972:  MOVFF  150,189
1976:  MOVFF  03,190
197A:  MOVFF  02,18F
197E:  MOVFF  01,18E
1982:  MOVFF  00,18D
1986:  RCALL  1574
1988:  MOVFF  03,14C
198C:  MOVFF  02,14B
1990:  MOVFF  01,14A
1994:  MOVFF  00,149
....................          } 
....................       } 
1998:  BRA    19A4
199A:  MOVLB  1
....................       else if (!skip) 
199C:  BTFSC  x4D.0
199E:  BRA    19A2
....................          break; 
19A0:  BRA    19BC
19A2:  MOVLB  0
19A4:  MOVLB  1
19A6:  MOVF   x4F,W
19A8:  INCF   x4F,F
19AA:  CLRF   03
19AC:  ADDWF  x41,W
19AE:  MOVWF  FE9
19B0:  MOVF   x42,W
19B2:  ADDWFC 03,W
19B4:  MOVWF  FEA
19B6:  MOVFF  FEF,14E
19BA:  BRA    182C
....................    } 
....................  
....................    if (sign) 
19BC:  BTFSS  x4D.1
19BE:  BRA    19F2
....................       result = -1*result; 
19C0:  CLRF   x8C
19C2:  CLRF   x8B
19C4:  MOVLW  80
19C6:  MOVWF  x8A
19C8:  MOVLW  7F
19CA:  MOVWF  x89
19CC:  MOVFF  14C,190
19D0:  MOVFF  14B,18F
19D4:  MOVFF  14A,18E
19D8:  MOVFF  149,18D
19DC:  MOVLB  0
19DE:  RCALL  12EA
19E0:  MOVFF  03,14C
19E4:  MOVFF  02,14B
19E8:  MOVFF  01,14A
19EC:  MOVFF  00,149
19F0:  MOVLB  1
....................        
....................    if(endptr) 
19F2:  MOVF   x43,W
19F4:  IORWF  x44,W
19F6:  BZ    1A26
....................    { 
....................       if (ptr) { 
19F8:  MOVF   x4F,F
19FA:  BZ    1A14
....................          ptr--; 
19FC:  DECF   x4F,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
19FE:  MOVFF  143,FE9
1A02:  MOVFF  144,FEA
1A06:  MOVF   x4F,W
1A08:  ADDWF  x41,W
1A0A:  MOVWF  FEF
1A0C:  MOVLW  00
1A0E:  ADDWFC x42,W
1A10:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
1A12:  BRA    1A26
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
1A14:  MOVFF  143,FE9
1A18:  MOVFF  144,FEA
1A1C:  MOVFF  142,FEC
1A20:  MOVF   FED,F
1A22:  MOVFF  141,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
1A26:  MOVFF  149,00
1A2A:  MOVFF  14A,01
1A2E:  MOVFF  14B,02
1A32:  MOVFF  14C,03
1A36:  MOVLB  0
1A38:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... int1 GPRMC_ok = 0, GPGGA_ok = 0; 
.................... uint8_t char_number = 0, SentenceType = 0, Term; 
.................... char sentence[6], rawTime[11], rawDate[7], rawSpeed[6], rawCourse[6], rawSatellites[3], 
....................      rawLatitude[13], rawLongitude[13], rawAltitude[7], buffer[12]; 
....................  
.................... void stringcpy(char *str1, char *str2, int1 dir = 0) { 
*
0326:  MOVLB  1
0328:  CLRF   x4D
....................   uint8_t chr = 0; 
....................   do { 
....................     str2[chr + dir] = str1[chr]; 
032A:  MOVF   x4C,W
032C:  ADDWF  x4D,W
032E:  CLRF   03
0330:  ADDWF  x4A,W
0332:  MOVWF  01
0334:  MOVF   x4B,W
0336:  ADDWFC 03,F
0338:  MOVFF  03,14F
033C:  CLRF   03
033E:  MOVF   x4D,W
0340:  ADDWF  x48,W
0342:  MOVWF  FE9
0344:  MOVF   x49,W
0346:  ADDWFC 03,W
0348:  MOVWF  FEA
034A:  MOVFF  FEF,150
034E:  MOVFF  14F,FEA
0352:  MOVFF  01,FE9
0356:  MOVFF  150,FEF
....................   } while(str1[chr++] != '\0'); 
035A:  MOVF   x4D,W
035C:  INCF   x4D,F
035E:  CLRF   03
0360:  ADDWF  x48,W
0362:  MOVWF  FE9
0364:  MOVF   x49,W
0366:  ADDWFC 03,W
0368:  MOVWF  FEA
036A:  MOVF   FEF,F
036C:  BNZ   032A
036E:  MOVLB  0
0370:  RETURN 0
.................... } 
....................  
.................... int1 GPSRead() { 
*
03EA:  BRA    030E
03EC:  MOVFF  01,141
....................   uint8_t c = getc(); 
....................  
....................   switch(c) { 
03F0:  MOVLB  1
03F2:  MOVF   x41,W
03F4:  XORLW  0D
03F6:  MOVLB  0
03F8:  BZ    0404
03FA:  XORLW  29
03FC:  BZ    0426
03FE:  XORLW  08
0400:  BZ    042E
0402:  BRA    05F0
....................     case '\r':  // sentence end 
....................       if(SentenceType == _GPRMC_) 
0404:  DECFSZ 0D,W
0406:  BRA    040A
....................         GPRMC_ok = 1; 
0408:  BSF    0B.0
....................       if(SentenceType == _GPGGA_) 
040A:  MOVF   0D,W
040C:  SUBLW  02
040E:  BNZ   0412
....................         GPGGA_ok = 1; 
0410:  BSF    0B.1
....................       if(GPRMC_ok && GPGGA_ok) { 
0412:  BTFSS  0B.0
0414:  BRA    0424
0416:  BTFSS  0B.1
0418:  BRA    0424
....................         GPRMC_ok = GPGGA_ok = 0; 
041A:  BCF    0B.1
041C:  BCF    0B.0
....................         return 1; 
041E:  MOVLW  01
0420:  MOVWF  01
0422:  BRA    0608
....................       } 
....................       break; 
0424:  BRA    0604
....................  
....................     case '$': // sentence start 
....................       Term = char_number = 0; 
0426:  CLRF   0C
0428:  MOVFF  0C,0E
....................       break; 
042C:  BRA    0604
....................  
....................     case ',':  // term end (new term start) 
....................       buffer[char_number] = '\0'; 
042E:  CLRF   03
0430:  MOVF   0C,W
0432:  ADDLW  57
0434:  MOVWF  FE9
0436:  MOVLW  00
0438:  ADDWFC 03,W
043A:  MOVWF  FEA
043C:  CLRF   FEF
....................       if(Term == 0) { 
043E:  MOVF   0E,F
0440:  BNZ   04C0
....................         stringcpy(buffer, sentence); 
0442:  MOVLB  1
0444:  CLRF   x49
0446:  MOVLW  57
0448:  MOVWF  x48
044A:  CLRF   x4B
044C:  MOVLW  0F
044E:  MOVWF  x4A
0450:  CLRF   x4C
0452:  MOVLB  0
0454:  RCALL  0326
....................         if(strcmp(sentence, "GPRMC") == 0) 
0456:  MOVLW  47
0458:  MOVLB  1
045A:  MOVWF  x42
045C:  MOVLW  50
045E:  MOVWF  x43
0460:  MOVLW  52
0462:  MOVWF  x44
0464:  MOVLW  4D
0466:  MOVWF  x45
0468:  MOVLW  43
046A:  MOVWF  x46
046C:  CLRF   x47
046E:  CLRF   x4B
0470:  MOVLW  0F
0472:  MOVWF  x4A
0474:  MOVLW  01
0476:  MOVWF  x4D
0478:  MOVLW  42
047A:  MOVWF  x4C
047C:  MOVLB  0
047E:  RCALL  0372
0480:  MOVF   01,F
0482:  BNZ   048A
....................           SentenceType = _GPRMC_; 
0484:  MOVLW  01
0486:  MOVWF  0D
0488:  BRA    04C0
....................         else if(strcmp(sentence, "GPGGA") == 0) 
048A:  MOVLW  47
048C:  MOVLB  1
048E:  MOVWF  x42
0490:  MOVLW  50
0492:  MOVWF  x43
0494:  MOVLW  47
0496:  MOVWF  x44
0498:  MOVWF  x45
049A:  MOVLW  41
049C:  MOVWF  x46
049E:  CLRF   x47
04A0:  CLRF   x4B
04A2:  MOVLW  0F
04A4:  MOVWF  x4A
04A6:  MOVLW  01
04A8:  MOVWF  x4D
04AA:  MOVLW  42
04AC:  MOVWF  x4C
04AE:  MOVLB  0
04B0:  RCALL  0372
04B2:  MOVF   01,F
04B4:  BNZ   04BC
....................                SentenceType = _GPGGA_; 
04B6:  MOVLW  02
04B8:  MOVWF  0D
04BA:  BRA    04C0
....................              else 
....................                SentenceType = _OTHER_; 
04BC:  MOVLW  03
04BE:  MOVWF  0D
....................       } 
....................  
....................       // Time 
....................       if(Term == 1 && SentenceType == _GPRMC_) { 
04C0:  DECFSZ 0E,W
04C2:  BRA    04DC
04C4:  DECFSZ 0D,W
04C6:  BRA    04DC
....................         stringcpy(buffer, rawTime); 
04C8:  MOVLB  1
04CA:  CLRF   x49
04CC:  MOVLW  57
04CE:  MOVWF  x48
04D0:  CLRF   x4B
04D2:  MOVLW  15
04D4:  MOVWF  x4A
04D6:  CLRF   x4C
04D8:  MOVLB  0
04DA:  RCALL  0326
....................       } 
....................  
....................       // Latitude 
....................       if((Term == 3) && (SentenceType == _GPRMC_)) { 
04DC:  MOVF   0E,W
04DE:  SUBLW  03
04E0:  BNZ   04FC
04E2:  DECFSZ 0D,W
04E4:  BRA    04FC
....................         stringcpy(buffer, rawLatitude, 1); 
04E6:  MOVLB  1
04E8:  CLRF   x49
04EA:  MOVLW  57
04EC:  MOVWF  x48
04EE:  CLRF   x4B
04F0:  MOVLW  36
04F2:  MOVWF  x4A
04F4:  MOVLW  01
04F6:  MOVWF  x4C
04F8:  MOVLB  0
04FA:  RCALL  0326
....................       } 
....................       // Latitude N/S 
....................       if((Term == 4) && (SentenceType == _GPRMC_)) { 
04FC:  MOVF   0E,W
04FE:  SUBLW  04
0500:  BNZ   0516
0502:  DECFSZ 0D,W
0504:  BRA    0516
....................         if(buffer[0] == 'N') 
0506:  MOVF   57,W
0508:  SUBLW  4E
050A:  BNZ   0512
....................           rawLatitude[0] = '0'; 
050C:  MOVLW  30
050E:  MOVWF  36
0510:  BRA    0516
....................         else 
....................           rawLatitude[0] = '-'; 
0512:  MOVLW  2D
0514:  MOVWF  36
....................       } 
....................  
....................       // Longitude 
....................       if((Term == 5) && (SentenceType == _GPRMC_)) { 
0516:  MOVF   0E,W
0518:  SUBLW  05
051A:  BNZ   0536
051C:  DECFSZ 0D,W
051E:  BRA    0536
....................         stringcpy(buffer, rawLongitude, 1); 
0520:  MOVLB  1
0522:  CLRF   x49
0524:  MOVLW  57
0526:  MOVWF  x48
0528:  CLRF   x4B
052A:  MOVLW  43
052C:  MOVWF  x4A
052E:  MOVLW  01
0530:  MOVWF  x4C
0532:  MOVLB  0
0534:  RCALL  0326
....................       } 
....................       // Longitude E/W 
....................       if((Term == 6) && (SentenceType == _GPRMC_)) { 
0536:  MOVF   0E,W
0538:  SUBLW  06
053A:  BNZ   0550
053C:  DECFSZ 0D,W
053E:  BRA    0550
....................         if(buffer[0] == 'E') 
0540:  MOVF   57,W
0542:  SUBLW  45
0544:  BNZ   054C
....................           rawLongitude[0] = '0'; 
0546:  MOVLW  30
0548:  MOVWF  43
054A:  BRA    0550
....................         else 
....................           rawLongitude[0] = '-'; 
054C:  MOVLW  2D
054E:  MOVWF  43
....................       } 
....................  
....................       // Speed 
....................       if((Term == 7) && (SentenceType == _GPRMC_)) { 
0550:  MOVF   0E,W
0552:  SUBLW  07
0554:  BNZ   056E
0556:  DECFSZ 0D,W
0558:  BRA    056E
....................         stringcpy(buffer, rawSpeed); 
055A:  MOVLB  1
055C:  CLRF   x49
055E:  MOVLW  57
0560:  MOVWF  x48
0562:  CLRF   x4B
0564:  MOVLW  27
0566:  MOVWF  x4A
0568:  CLRF   x4C
056A:  MOVLB  0
056C:  RCALL  0326
....................       } 
....................  
....................       // Course 
....................       if((Term == 8) && (SentenceType == _GPRMC_)) { 
056E:  MOVF   0E,W
0570:  SUBLW  08
0572:  BNZ   058C
0574:  DECFSZ 0D,W
0576:  BRA    058C
....................         stringcpy(buffer, rawCourse); 
0578:  MOVLB  1
057A:  CLRF   x49
057C:  MOVLW  57
057E:  MOVWF  x48
0580:  CLRF   x4B
0582:  MOVLW  2D
0584:  MOVWF  x4A
0586:  CLRF   x4C
0588:  MOVLB  0
058A:  RCALL  0326
....................       } 
....................  
....................       // Date 
....................       if(Term == 9 && SentenceType == _GPRMC_) { 
058C:  MOVF   0E,W
058E:  SUBLW  09
0590:  BNZ   05AA
0592:  DECFSZ 0D,W
0594:  BRA    05AA
....................         stringcpy(buffer, rawDate); 
0596:  MOVLB  1
0598:  CLRF   x49
059A:  MOVLW  57
059C:  MOVWF  x48
059E:  CLRF   x4B
05A0:  MOVLW  20
05A2:  MOVWF  x4A
05A4:  CLRF   x4C
05A6:  MOVLB  0
05A8:  RCALL  0326
....................       } 
....................  
....................       // Satellites 
....................       if((Term == 7) && (SentenceType == _GPGGA_)) { 
05AA:  MOVF   0E,W
05AC:  SUBLW  07
05AE:  BNZ   05CA
05B0:  MOVF   0D,W
05B2:  SUBLW  02
05B4:  BNZ   05CA
....................         stringcpy(buffer, rawSatellites); 
05B6:  MOVLB  1
05B8:  CLRF   x49
05BA:  MOVLW  57
05BC:  MOVWF  x48
05BE:  CLRF   x4B
05C0:  MOVLW  33
05C2:  MOVWF  x4A
05C4:  CLRF   x4C
05C6:  MOVLB  0
05C8:  RCALL  0326
....................       } 
....................  
....................       // Altitude 
....................       if((Term == 9) && (SentenceType == _GPGGA_)) { 
05CA:  MOVF   0E,W
05CC:  SUBLW  09
05CE:  BNZ   05EA
05D0:  MOVF   0D,W
05D2:  SUBLW  02
05D4:  BNZ   05EA
....................         stringcpy(buffer, rawAltitude); 
05D6:  MOVLB  1
05D8:  CLRF   x49
05DA:  MOVLW  57
05DC:  MOVWF  x48
05DE:  CLRF   x4B
05E0:  MOVLW  50
05E2:  MOVWF  x4A
05E4:  CLRF   x4C
05E6:  MOVLB  0
05E8:  RCALL  0326
....................       } 
....................       Term++; 
05EA:  INCF   0E,F
....................       char_number = 0; 
05EC:  CLRF   0C
....................       break; 
05EE:  BRA    0604
....................  
....................     default: 
....................       buffer[char_number++] = c; 
05F0:  MOVF   0C,W
05F2:  INCF   0C,F
05F4:  CLRF   03
05F6:  ADDLW  57
05F8:  MOVWF  FE9
05FA:  MOVLW  00
05FC:  ADDWFC 03,W
05FE:  MOVWF  FEA
0600:  MOVFF  141,FEF
....................       break; 
....................   } 
....................  
....................   return 0; 
0604:  MOVLW  00
0606:  MOVWF  01
0608:  GOTO   2C28 (RETURN)
.................... } 
....................  
.................... uint8_t GPSSecond() { 
....................   return ((rawTime[4] - '0') * 10 + (rawTime[5] - '0')); 
*
0640:  MOVLW  30
0642:  SUBWF  19,W
0644:  MULLW  0A
0646:  MOVFF  FF3,141
064A:  MOVLB  1
064C:  MOVLW  30
064E:  SUBWF  1A,W
0650:  ADDWF  x41,W
0652:  MOVWF  01
0654:  MOVLB  0
0656:  GOTO   2C64 (RETURN)
.................... } 
.................... uint8_t GPSMinute() { 
....................   return ((rawTime[2] - '0') * 10 + (rawTime[3] - '0')); 
*
0626:  MOVLW  30
0628:  SUBWF  17,W
062A:  MULLW  0A
062C:  MOVFF  FF3,141
0630:  MOVLB  1
0632:  MOVLW  30
0634:  SUBWF  18,W
0636:  ADDWF  x41,W
0638:  MOVWF  01
063A:  MOVLB  0
063C:  GOTO   2C5C (RETURN)
.................... } 
.................... uint8_t GPSHour() { 
....................   return ((rawTime[0] - '0') * 10 + (rawTime[1] - '0')); 
*
060C:  MOVLW  30
060E:  SUBWF  15,W
0610:  MULLW  0A
0612:  MOVFF  FF3,141
0616:  MOVLB  1
0618:  MOVLW  30
061A:  SUBWF  16,W
061C:  ADDWF  x41,W
061E:  MOVWF  01
0620:  MOVLB  0
0622:  GOTO   2C54 (RETURN)
.................... } 
....................  
.................... uint8_t GPSDay() { 
....................   return ((rawDate[0] - '0') * 10 + (rawDate[1] - '0')); 
*
065A:  MOVLW  30
065C:  SUBWF  20,W
065E:  MULLW  0A
0660:  MOVFF  FF3,141
0664:  MOVLB  1
0666:  MOVLW  30
0668:  SUBWF  21,W
066A:  ADDWF  x41,W
066C:  MOVWF  01
066E:  MOVLB  0
0670:  GOTO   2C6C (RETURN)
.................... } 
.................... uint8_t GPSMonth() { 
....................   return ((rawDate[2] - '0') * 10 + (rawDate[3] - '0')); 
0674:  MOVLW  30
0676:  SUBWF  22,W
0678:  MULLW  0A
067A:  MOVFF  FF3,141
067E:  MOVLB  1
0680:  MOVLW  30
0682:  SUBWF  23,W
0684:  ADDWF  x41,W
0686:  MOVWF  01
0688:  MOVLB  0
068A:  GOTO   2C74 (RETURN)
.................... } 
.................... uint8_t GPSyear() { 
....................   return ((rawDate[4] - '0') * 10 + (rawDate[5] - '0')); 
068E:  MOVLW  30
0690:  SUBWF  24,W
0692:  MULLW  0A
0694:  MOVFF  FF3,141
0698:  MOVLB  1
069A:  MOVLW  30
069C:  SUBWF  25,W
069E:  ADDWF  x41,W
06A0:  MOVWF  01
06A2:  MOVLB  0
06A4:  GOTO   2C82 (RETURN)
.................... } 
....................  
.................... float parse_rawDegree(char *term_) { 
....................   float term_value = atof(term_)/100; 
....................   int16_t term_dec = term_value; 
....................   term_value -= term_dec; 
....................   term_value  = term_value * 5/3 + term_dec; 
....................   return term_value; 
.................... } 
....................  
.................... float Latitude() { 
....................   return parse_rawDegree(rawLatitude); 
.................... } 
....................  
.................... float Longitude() { 
....................   return parse_rawDegree(rawLongitude); 
.................... } 
....................  
.................... float Altitude() { 
....................   return atof(rawAltitude); 
.................... } 
....................  
.................... uint8_t Satellites() { 
....................   return atoi(rawSatellites); 
.................... } 
....................  
.................... float Speed() { 
....................   return (atof(rawSpeed) * 1.852); 
.................... } 
....................  
.................... float Course() { 
....................   return atof(rawCourse); 
.................... } 
....................  
....................  
.................... //incluye librerias de tiempo  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() has another input parameter which is the pointer to where /// 
.................... ///     the input string is.  Normally ctime() and asctime() write the    /// 
.................... ///     output to a globally allocated string and return a pointer to     /// 
.................... ///     this string.  This library doesn't want to make this assumption   /// 
.................... ///     so the library doesn't allocate the space needed for those        /// 
.................... ///     functions.                                                        /// 
.................... ///   * asctime() has nother input parameter which is the pointer to      /// 
.................... ///     where the input string is.  See the above paragraph.              /// 
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (0-30) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* Functions */ 
.................... clock_t clock(void); 
.................... time_t time(time_t * timer); 
.................... signed int32 difftime(time_t later, time_t earlier); 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... char * asctime(struct_tm * timeptr, char *szTime); 
.................... char * ctime(time_t * timer, char *szTime); 
.................... struct_tm * localtime ( time_t * timer ); 
.................... void SetTime(struct_tm * nTime); 
.................... void SetTimeSec(time_t sTime); 
.................... void GetTime(struct_tm *pRetTm); 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include <time.c>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              time.c                                 /// 
.................... ///                                                                     /// 
.................... /// Contains common time routines that can be used by several           /// 
.................... /// timebases, and the runtime code needed for time.h.                  /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_C__ 
.................... #define __TIME_C__ 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
.................... { 
....................    switch(month) 
*
07FC:  MOVLB  1
07FE:  MOVF   x4F,W
0800:  XORLW  00
0802:  MOVLB  0
0804:  BZ    0834
0806:  XORLW  02
0808:  BZ    0834
080A:  XORLW  06
080C:  BZ    0834
080E:  XORLW  02
0810:  BZ    0834
0812:  XORLW  01
0814:  BZ    0834
0816:  XORLW  0E
0818:  BZ    0834
081A:  XORLW  02
081C:  BZ    0834
081E:  XORLW  0A
0820:  BZ    083A
0822:  XORLW  02
0824:  BZ    0852
0826:  XORLW  06
0828:  BZ    0852
082A:  XORLW  0D
082C:  BZ    0852
082E:  XORLW  02
0830:  BZ    0852
0832:  BRA    0858
....................    { 
....................       case JANUARY: 
....................       case MARCH: 
....................       case MAY: 
....................       case JULY: 
....................       case AUGUST: 
....................       case OCTOBER: 
....................       case DECEMBER: 
....................          return 31; 
0834:  MOVLW  1F
0836:  MOVWF  01
0838:  BRA    085C
....................  
....................       case FEBRUARY: 
....................          if(IsLeapYear) 
083A:  MOVLB  1
083C:  MOVF   x50,F
083E:  BZ    084A
....................             return 29;             
0840:  MOVLW  1D
0842:  MOVWF  01
0844:  MOVLB  0
0846:  BRA    085C
0848:  MOVLB  1
....................          return 28; 
084A:  MOVLW  1C
084C:  MOVWF  01
084E:  MOVLB  0
0850:  BRA    085C
....................  
....................       case APRIL: 
....................       case JUNE: 
....................       case SEPTEMBER: 
....................       case NOVEMBER: 
....................          return 30; 
0852:  MOVLW  1E
0854:  MOVWF  01
0856:  BRA    085C
....................        
....................       // error 
....................       default: 
....................          return 0; 
0858:  MOVLW  00
085A:  MOVWF  01
....................    } 
085C:  RETURN 0
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... int1 LeapYear(unsigned int16 year) 
.................... { 
....................    if( ((year + 1900) % 400 == 0) ||  
....................        (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
0748:  MOVLW  6C
074A:  MOVLB  1
074C:  ADDWF  x4C,W
074E:  MOVWF  x4E
0750:  MOVLW  07
0752:  ADDWFC x4D,W
0754:  MOVWF  x4F
0756:  MOVWF  x51
0758:  MOVFF  14E,150
075C:  MOVLW  01
075E:  MOVWF  x53
0760:  MOVLW  90
0762:  MOVWF  x52
0764:  MOVLB  0
0766:  RCALL  0702
0768:  MOVFF  00,14E
076C:  MOVLB  1
076E:  MOVFF  03,14F
0772:  MOVF   x4E,F
0774:  BNZ   077A
0776:  MOVF   x4F,F
0778:  BZ    07C2
077A:  MOVLW  6C
077C:  ADDWF  x4C,W
077E:  MOVWF  x4E
0780:  MOVLW  07
0782:  ADDWFC x4D,W
0784:  MOVWF  x4F
0786:  MOVLW  03
0788:  ANDWF  x4E,F
078A:  CLRF   x4F
078C:  MOVF   x4E,F
078E:  BNZ   07C8
0790:  MOVF   x4F,F
0792:  BNZ   07C8
0794:  MOVLW  6C
0796:  ADDWF  x4C,W
0798:  MOVWF  x4E
079A:  MOVLW  07
079C:  ADDWFC x4D,W
079E:  MOVWF  x4F
07A0:  MOVWF  x51
07A2:  MOVFF  14E,150
07A6:  CLRF   x53
07A8:  MOVLW  64
07AA:  MOVWF  x52
07AC:  MOVLB  0
07AE:  RCALL  0702
07B0:  MOVFF  00,14E
07B4:  MOVLB  1
07B6:  MOVFF  03,14F
07BA:  MOVF   x4E,F
07BC:  BNZ   07C2
07BE:  MOVF   x4F,F
07C0:  BZ    07C8
....................       return TRUE; 
07C2:  MOVLW  01
07C4:  MOVWF  01
07C6:  BRA    07CC
....................       
....................    return FALSE; 
07C8:  MOVLW  00
07CA:  MOVWF  01
07CC:  MOVLB  0
07CE:  RETURN 0
.................... } 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT) 
*
0948:  MOVLB  1
094A:  CLRF   x46
094C:  CLRF   x45
094E:  CLRF   x44
0950:  CLRF   x43
0952:  BCF    x47.0
0954:  CLRF   x49
0956:  CLRF   x48
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
0958:  MOVF   x41,F
095A:  BNZ   0962
095C:  MOVF   x42,F
095E:  BTFSC  FD8.2
0960:  BRA    0E0E
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
0962:  MOVFF  141,FE9
0966:  MOVFF  142,FEA
096A:  MOVF   FEF,W
096C:  ADDWF  x43,F
096E:  MOVLW  00
0970:  ADDWFC x44,F
0972:  ADDWFC x45,F
0974:  ADDWFC x46,F
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
0976:  MOVLW  01
0978:  ADDWF  x41,W
097A:  MOVWF  FE9
097C:  MOVLW  00
097E:  ADDWFC x42,W
0980:  MOVWF  FEA
0982:  MOVF   FEF,W
0984:  CLRF   x4D
0986:  CLRF   x4C
0988:  CLRF   x4B
098A:  MOVWF  x4A
098C:  MOVFF  FEA,14F
0990:  MOVFF  FE9,14E
0994:  MOVFF  14D,153
0998:  MOVFF  14C,152
099C:  MOVFF  14B,151
09A0:  MOVWF  x50
09A2:  CLRF   x57
09A4:  CLRF   x56
09A6:  CLRF   x55
09A8:  MOVLW  3C
09AA:  MOVWF  x54
09AC:  MOVLB  0
09AE:  RCALL  06A8
09B0:  MOVFF  14F,FEA
09B4:  MOVFF  14E,FE9
09B8:  MOVF   00,W
09BA:  MOVLB  1
09BC:  ADDWF  x43,F
09BE:  MOVF   01,W
09C0:  ADDWFC x44,F
09C2:  MOVF   02,W
09C4:  ADDWFC x45,F
09C6:  MOVF   03,W
09C8:  ADDWFC x46,F
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
09CA:  MOVLW  02
09CC:  ADDWF  x41,W
09CE:  MOVWF  FE9
09D0:  MOVLW  00
09D2:  ADDWFC x42,W
09D4:  MOVWF  FEA
09D6:  MOVF   FEF,W
09D8:  CLRF   x4D
09DA:  CLRF   x4C
09DC:  CLRF   x4B
09DE:  MOVWF  x4A
09E0:  MOVFF  FEA,14F
09E4:  MOVFF  FE9,14E
09E8:  MOVFF  14D,153
09EC:  MOVFF  14C,152
09F0:  MOVFF  14B,151
09F4:  MOVWF  x50
09F6:  CLRF   x57
09F8:  CLRF   x56
09FA:  MOVLW  0E
09FC:  MOVWF  x55
09FE:  MOVLW  10
0A00:  MOVWF  x54
0A02:  MOVLB  0
0A04:  RCALL  06A8
0A06:  MOVFF  14F,FEA
0A0A:  MOVFF  14E,FE9
0A0E:  MOVF   00,W
0A10:  MOVLB  1
0A12:  ADDWF  x43,F
0A14:  MOVF   01,W
0A16:  ADDWFC x44,F
0A18:  MOVF   02,W
0A1A:  ADDWFC x45,F
0A1C:  MOVF   03,W
0A1E:  ADDWFC x46,F
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
0A20:  MOVLW  05
0A22:  ADDWF  x41,W
0A24:  MOVWF  FE9
0A26:  MOVLW  00
0A28:  ADDWFC x42,W
0A2A:  MOVWF  FEA
0A2C:  MOVFF  FEC,14B
0A30:  MOVF   FED,F
0A32:  MOVFF  FEF,14A
0A36:  MOVFF  14B,14D
0A3A:  MOVFF  14A,14C
0A3E:  MOVLB  0
0A40:  RCALL  0748
0A42:  MOVLB  1
0A44:  BCF    x47.0
0A46:  BTFSC  01.0
0A48:  BSF    x47.0
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
0A4A:  MOVLW  04
0A4C:  ADDWF  x41,W
0A4E:  MOVWF  FE9
0A50:  MOVLW  00
0A52:  ADDWFC x42,W
0A54:  MOVWF  FEA
0A56:  MOVFF  FEF,14D
0A5A:  MOVLW  0C
0A5C:  MOVWF  x4E
0A5E:  MOVLB  0
0A60:  RCALL  07D0
0A62:  MOVFF  00,FEF
....................       for(i = 1;i <= timeT->tm_mon;i++) 
0A66:  MOVLB  1
0A68:  CLRF   x49
0A6A:  MOVLW  01
0A6C:  MOVWF  x48
0A6E:  MOVLW  04
0A70:  ADDWF  x41,W
0A72:  MOVWF  FE9
0A74:  MOVLW  00
0A76:  ADDWFC x42,W
0A78:  MOVWF  FEA
0A7A:  MOVF   FEF,W
0A7C:  MOVF   x49,F
0A7E:  BNZ   0AEC
0A80:  SUBWF  x48,W
0A82:  BZ    0A86
0A84:  BC    0AEC
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
0A86:  MOVLW  01
0A88:  SUBWF  x48,W
0A8A:  MOVWF  x4A
0A8C:  MOVLW  00
0A8E:  SUBWFB x49,W
0A90:  MOVWF  x4B
0A92:  MOVLW  00
0A94:  BTFSC  x47.0
0A96:  MOVLW  01
0A98:  MOVWF  x4C
0A9A:  MOVFF  14A,14F
0A9E:  MOVWF  x50
0AA0:  MOVLB  0
0AA2:  RCALL  07FC
0AA4:  MOVFF  FEA,14C
0AA8:  MOVFF  FE9,14B
0AAC:  MOVLB  1
0AAE:  CLRF   x53
0AB0:  CLRF   x52
0AB2:  CLRF   x51
0AB4:  MOVFF  01,150
0AB8:  CLRF   x57
0ABA:  MOVLW  01
0ABC:  MOVWF  x56
0ABE:  MOVLW  51
0AC0:  MOVWF  x55
0AC2:  MOVLW  80
0AC4:  MOVWF  x54
0AC6:  MOVLB  0
0AC8:  RCALL  06A8
0ACA:  MOVFF  14C,FEA
0ACE:  MOVFF  14B,FE9
0AD2:  MOVF   00,W
0AD4:  MOVLB  1
0AD6:  ADDWF  x43,F
0AD8:  MOVF   01,W
0ADA:  ADDWFC x44,F
0ADC:  MOVF   02,W
0ADE:  ADDWFC x45,F
0AE0:  MOVF   03,W
0AE2:  ADDWFC x46,F
0AE4:  INCF   x48,F
0AE6:  BTFSC  FD8.2
0AE8:  INCF   x49,F
0AEA:  BRA    0A6E
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
0AEC:  MOVLW  03
0AEE:  ADDWF  x41,W
0AF0:  MOVWF  01
0AF2:  MOVLW  00
0AF4:  ADDWFC x42,W
0AF6:  MOVWF  03
0AF8:  MOVFF  01,14A
0AFC:  MOVWF  x4B
0AFE:  MOVWF  FEA
0B00:  MOVFF  01,FE9
0B04:  MOVFF  FEF,14C
0B08:  MOVLW  04
0B0A:  ADDWF  x41,W
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC x42,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEF,14D
0B18:  MOVLW  00
0B1A:  BTFSC  x47.0
0B1C:  MOVLW  01
0B1E:  MOVWF  x4E
0B20:  MOVFF  14D,14F
0B24:  MOVWF  x50
0B26:  MOVLB  0
0B28:  RCALL  07FC
0B2A:  MOVFF  14C,14D
0B2E:  MOVFF  01,14E
0B32:  RCALL  07D0
0B34:  MOVLB  1
0B36:  MOVFF  14B,FEA
0B3A:  MOVFF  14A,FE9
0B3E:  MOVFF  00,FEF
....................       unixTime += (timeT->tm_mday) * 86400; 
0B42:  MOVLW  03
0B44:  ADDWF  x41,W
0B46:  MOVWF  FE9
0B48:  MOVLW  00
0B4A:  ADDWFC x42,W
0B4C:  MOVWF  FEA
0B4E:  MOVFF  FEA,14C
0B52:  MOVFF  FE9,14B
0B56:  CLRF   x53
0B58:  CLRF   x52
0B5A:  CLRF   x51
0B5C:  MOVFF  FEF,150
0B60:  CLRF   x57
0B62:  MOVLW  01
0B64:  MOVWF  x56
0B66:  MOVLW  51
0B68:  MOVWF  x55
0B6A:  MOVLW  80
0B6C:  MOVWF  x54
0B6E:  MOVLB  0
0B70:  RCALL  06A8
0B72:  MOVFF  14C,FEA
0B76:  MOVFF  14B,FE9
0B7A:  MOVF   00,W
0B7C:  MOVLB  1
0B7E:  ADDWF  x43,F
0B80:  MOVF   01,W
0B82:  ADDWFC x44,F
0B84:  MOVF   02,W
0B86:  ADDWFC x45,F
0B88:  MOVF   03,W
0B8A:  ADDWFC x46,F
....................        
....................       if(isLeapYear) 
0B8C:  BTFSS  x47.0
0B8E:  BRA    0C38
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
0B90:  MOVLW  08
0B92:  ADDWF  x41,W
0B94:  MOVWF  01
0B96:  MOVLW  00
0B98:  ADDWFC x42,W
0B9A:  MOVWF  03
0B9C:  MOVFF  01,14A
0BA0:  MOVWF  x4B
0BA2:  MOVFF  FEA,14D
0BA6:  MOVFF  FE9,14C
0BAA:  BCF    FD8.1
0BAC:  MOVFF  146,15B
0BB0:  MOVFF  145,15A
0BB4:  MOVFF  144,159
0BB8:  MOVFF  143,158
0BBC:  CLRF   x5F
0BBE:  MOVLW  01
0BC0:  MOVWF  x5E
0BC2:  MOVLW  51
0BC4:  MOVWF  x5D
0BC6:  MOVLW  80
0BC8:  MOVWF  x5C
0BCA:  MOVLB  0
0BCC:  RCALL  085E
0BCE:  MOVFF  14D,FEA
0BD2:  MOVFF  14C,FE9
0BD6:  MOVFF  03,151
0BDA:  MOVFF  02,150
0BDE:  MOVFF  01,14F
0BE2:  MOVFF  00,14E
0BE6:  MOVFF  FEA,153
0BEA:  MOVFF  FE9,152
0BEE:  BSF    FD8.1
0BF0:  MOVLW  01
0BF2:  MOVWF  FEA
0BF4:  MOVLW  54
0BF6:  MOVWF  FE9
0BF8:  MOVFF  03,15B
0BFC:  MOVFF  02,15A
0C00:  MOVFF  01,159
0C04:  MOVFF  00,158
0C08:  MOVLB  1
0C0A:  CLRF   x5F
0C0C:  CLRF   x5E
0C0E:  MOVLW  01
0C10:  MOVWF  x5D
0C12:  MOVLW  6E
0C14:  MOVWF  x5C
0C16:  MOVLB  0
0C18:  RCALL  085E
0C1A:  MOVFF  153,FEA
0C1E:  MOVFF  152,FE9
0C22:  MOVFF  14B,FEA
0C26:  MOVFF  14A,FE9
0C2A:  MOVFF  155,FEC
0C2E:  MOVF   FED,F
0C30:  MOVFF  154,FEF
....................       } 
0C34:  BRA    0CDC
0C36:  MOVLB  1
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
0C38:  MOVLW  08
0C3A:  ADDWF  x41,W
0C3C:  MOVWF  01
0C3E:  MOVLW  00
0C40:  ADDWFC x42,W
0C42:  MOVWF  03
0C44:  MOVFF  01,14A
0C48:  MOVWF  x4B
0C4A:  MOVFF  FEA,14D
0C4E:  MOVFF  FE9,14C
0C52:  BCF    FD8.1
0C54:  MOVFF  146,15B
0C58:  MOVFF  145,15A
0C5C:  MOVFF  144,159
0C60:  MOVFF  143,158
0C64:  CLRF   x5F
0C66:  MOVLW  01
0C68:  MOVWF  x5E
0C6A:  MOVLW  51
0C6C:  MOVWF  x5D
0C6E:  MOVLW  80
0C70:  MOVWF  x5C
0C72:  MOVLB  0
0C74:  RCALL  085E
0C76:  MOVFF  14D,FEA
0C7A:  MOVFF  14C,FE9
0C7E:  MOVFF  03,151
0C82:  MOVFF  02,150
0C86:  MOVFF  01,14F
0C8A:  MOVFF  00,14E
0C8E:  MOVFF  FEA,153
0C92:  MOVFF  FE9,152
0C96:  BSF    FD8.1
0C98:  MOVLW  01
0C9A:  MOVWF  FEA
0C9C:  MOVLW  54
0C9E:  MOVWF  FE9
0CA0:  MOVFF  03,15B
0CA4:  MOVFF  02,15A
0CA8:  MOVFF  01,159
0CAC:  MOVFF  00,158
0CB0:  MOVLB  1
0CB2:  CLRF   x5F
0CB4:  CLRF   x5E
0CB6:  MOVLW  01
0CB8:  MOVWF  x5D
0CBA:  MOVLW  6D
0CBC:  MOVWF  x5C
0CBE:  MOVLB  0
0CC0:  RCALL  085E
0CC2:  MOVFF  153,FEA
0CC6:  MOVFF  152,FE9
0CCA:  MOVFF  14B,FEA
0CCE:  MOVFF  14A,FE9
0CD2:  MOVFF  155,FEC
0CD6:  MOVF   FED,F
0CD8:  MOVFF  154,FEF
....................       } 
....................        
....................       i = 70; 
0CDC:  MOVLB  1
0CDE:  CLRF   x49
0CE0:  MOVLW  46
0CE2:  MOVWF  x48
....................       if(timeT->tm_year - 70 >= 0) 
0CE4:  MOVLW  05
0CE6:  ADDWF  x41,W
0CE8:  MOVWF  FE9
0CEA:  MOVLW  00
0CEC:  ADDWFC x42,W
0CEE:  MOVWF  FEA
0CF0:  MOVFF  FEC,14B
0CF4:  MOVF   FED,F
0CF6:  MOVFF  FEF,14A
0CFA:  MOVLW  46
0CFC:  SUBWF  x4A,F
0CFE:  MOVLW  00
0D00:  SUBWFB x4B,F
....................       { 
....................          while(i < (timeT->tm_year)) 
0D02:  MOVLW  05
0D04:  ADDWF  x41,W
0D06:  MOVWF  FE9
0D08:  MOVLW  00
0D0A:  ADDWFC x42,W
0D0C:  MOVWF  FEA
0D0E:  MOVFF  FEC,03
0D12:  MOVF   FED,F
0D14:  MOVFF  FEF,01
0D18:  MOVF   x49,W
0D1A:  SUBWF  03,W
0D1C:  BNC   0D64
0D1E:  BNZ   0D26
0D20:  MOVF   01,W
0D22:  SUBWF  x48,W
0D24:  BC    0D64
....................          { 
....................             isLeapYear = LeapYear(i); 
0D26:  MOVFF  149,14D
0D2A:  MOVFF  148,14C
0D2E:  MOVLB  0
0D30:  RCALL  0748
0D32:  MOVLB  1
0D34:  BCF    x47.0
0D36:  BTFSC  01.0
0D38:  BSF    x47.0
....................             if(isLeapYear) 
0D3A:  BTFSS  x47.0
0D3C:  BRA    0D4C
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
0D3E:  MOVLW  85
0D40:  ADDWF  x44,F
0D42:  MOVLW  E2
0D44:  ADDWFC x45,F
0D46:  MOVLW  01
0D48:  ADDWFC x46,F
....................             } 
0D4A:  BRA    0D5C
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
0D4C:  MOVLW  80
0D4E:  ADDWF  x43,F
0D50:  MOVLW  33
0D52:  ADDWFC x44,F
0D54:  MOVLW  E1
0D56:  ADDWFC x45,F
0D58:  MOVLW  01
0D5A:  ADDWFC x46,F
....................             } 
....................             i++; 
0D5C:  INCF   x48,F
0D5E:  BTFSC  FD8.2
0D60:  INCF   x49,F
0D62:  BRA    0D02
....................          } 
....................       } 
....................        
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
0D64:  MOVLW  07
0D66:  ADDWF  x41,W
0D68:  MOVWF  01
0D6A:  MOVLW  00
0D6C:  ADDWFC x42,W
0D6E:  MOVWF  03
0D70:  MOVFF  01,14A
0D74:  MOVWF  x4B
0D76:  MOVFF  FEA,14D
0D7A:  MOVFF  FE9,14C
0D7E:  BCF    FD8.1
0D80:  MOVFF  146,15B
0D84:  MOVFF  145,15A
0D88:  MOVFF  144,159
0D8C:  MOVFF  143,158
0D90:  CLRF   x5F
0D92:  MOVLW  01
0D94:  MOVWF  x5E
0D96:  MOVLW  51
0D98:  MOVWF  x5D
0D9A:  MOVLW  80
0D9C:  MOVWF  x5C
0D9E:  MOVLB  0
0DA0:  RCALL  085E
0DA2:  MOVFF  14D,FEA
0DA6:  MOVFF  14C,FE9
0DAA:  MOVFF  03,151
0DAE:  MOVFF  02,150
0DB2:  MOVFF  01,14F
0DB6:  MOVFF  00,14E
0DBA:  MOVLW  04
0DBC:  MOVLB  1
0DBE:  ADDWF  x4E,F
0DC0:  MOVLW  00
0DC2:  ADDWFC x4F,F
0DC4:  ADDWFC x50,F
0DC6:  ADDWFC x51,F
0DC8:  MOVFF  FEA,153
0DCC:  MOVFF  FE9,152
0DD0:  BSF    FD8.1
0DD2:  MOVLW  01
0DD4:  MOVWF  FEA
0DD6:  MOVLW  54
0DD8:  MOVWF  FE9
0DDA:  MOVFF  151,15B
0DDE:  MOVFF  150,15A
0DE2:  MOVFF  14F,159
0DE6:  MOVFF  14E,158
0DEA:  CLRF   x5F
0DEC:  CLRF   x5E
0DEE:  CLRF   x5D
0DF0:  MOVLW  07
0DF2:  MOVWF  x5C
0DF4:  MOVLB  0
0DF6:  RCALL  085E
0DF8:  MOVFF  153,FEA
0DFC:  MOVFF  152,FE9
0E00:  MOVFF  14B,FEA
0E04:  MOVFF  14A,FE9
0E08:  MOVFF  154,FEF
0E0C:  MOVLB  1
....................    } 
....................  
....................    return unixTime; 
0E0E:  MOVFF  143,00
0E12:  MOVFF  144,01
0E16:  MOVFF  145,02
0E1A:  MOVFF  146,03
0E1E:  MOVLB  0
0E20:  GOTO   2C98 (RETURN)
.................... } 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime ( struct_tm * timeptr, char * szTime) 
.................... { 
....................    char szDay[8]; 
....................    char szMon[8]; 
....................     
....................    WeekdayAbbreviations(timeptr->tm_wday, szDay); 
....................    MonthAbbreviations(timeptr->tm_mon, szMon); 
....................     
....................    sprintf(szTime,"%s %s %d %02d:%02d:%02d %04Lu", 
....................       szDay, 
....................       szMon, 
....................       timeptr->tm_mday + 1, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + 1900)); 
....................        
....................    return szTime; 
.................... } 
....................  
.................... /* Converts the given calendar time (in seconds) to local time  
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime ( time_t * timer, char *szTime ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime(time_t * timer) 
*
0E48:  MOVLB  1
0E4A:  BCF    x47.0
0E4C:  BCF    x47.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;//1970 is not a leap year 
....................  
....................    if(timer != NULL) 
0E4E:  MOVF   x41,F
0E50:  BNZ   0E58
0E52:  MOVF   x42,F
0E54:  BTFSC  FD8.2
0E56:  BRA    1222
....................    { 
....................       timeCounter = *timer; 
0E58:  MOVFF  141,FE9
0E5C:  MOVFF  142,FEA
0E60:  MOVFF  FEF,143
0E64:  MOVFF  FEC,144
0E68:  MOVFF  FEC,145
0E6C:  MOVFF  FEC,146
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
0E70:  BCF    FD8.1
0E72:  MOVFF  146,15B
0E76:  MOVFF  145,15A
0E7A:  MOVFF  144,159
0E7E:  MOVFF  143,158
0E82:  CLRF   x5F
0E84:  MOVLW  01
0E86:  MOVWF  x5E
0E88:  MOVLW  51
0E8A:  MOVWF  x5D
0E8C:  MOVLW  80
0E8E:  MOVWF  x5C
0E90:  MOVLB  0
0E92:  RCALL  085E
0E94:  MOVFF  03,14B
0E98:  MOVFF  02,14A
0E9C:  MOVFF  01,149
0EA0:  MOVFF  00,148
0EA4:  MOVLW  04
0EA6:  MOVLB  1
0EA8:  ADDWF  x48,F
0EAA:  MOVLW  00
0EAC:  ADDWFC x49,F
0EAE:  ADDWFC x4A,F
0EB0:  ADDWFC x4B,F
0EB2:  BSF    FD8.1
0EB4:  MOVLW  01
0EB6:  MOVWF  FEA
0EB8:  MOVLW  4C
0EBA:  MOVWF  FE9
0EBC:  MOVFF  14B,15B
0EC0:  MOVFF  14A,15A
0EC4:  MOVFF  149,159
0EC8:  MOVFF  148,158
0ECC:  CLRF   x5F
0ECE:  CLRF   x5E
0ED0:  CLRF   x5D
0ED2:  MOVLW  07
0ED4:  MOVWF  x5C
0ED6:  MOVLB  0
0ED8:  RCALL  085E
0EDA:  MOVFF  14C,6E
....................       g_lTime.tm_year = 70;//we are starting in 1970 
0EDE:  CLRF   x6D
0EE0:  MOVLW  46
0EE2:  MOVWF  x6C
....................        
....................       while(!done) 
0EE4:  MOVLB  1
0EE6:  BTFSC  x47.0
0EE8:  BRA    0FD0
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
0EEA:  BTFSC  x46.7
0EEC:  BRA    0F04
0EEE:  MOVF   x46,W
0EF0:  SUBLW  01
0EF2:  BNC   0F3A
0EF4:  BNZ   0F04
0EF6:  MOVF   x45,W
0EF8:  SUBLW  E2
0EFA:  BNC   0F3A
0EFC:  BNZ   0F04
0EFE:  MOVF   x44,W
0F00:  SUBLW  84
0F02:  BNC   0F3A
0F04:  BTFSS  x47.1
0F06:  BRA    0F3A
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
0F08:  BCF    FD8.1
0F0A:  MOVFF  146,15B
0F0E:  MOVFF  145,15A
0F12:  MOVFF  144,159
0F16:  MOVFF  143,158
0F1A:  CLRF   x5F
0F1C:  MOVLW  01
0F1E:  MOVWF  x5E
0F20:  MOVLW  51
0F22:  MOVWF  x5D
0F24:  MOVLW  80
0F26:  MOVWF  x5C
0F28:  MOVLB  0
0F2A:  RCALL  085E
0F2C:  MOVFF  01,70
0F30:  MOVFF  00,6F
....................             break; 
0F34:  MOVLB  1
0F36:  BRA    0FD0
....................          } 
0F38:  BRA    0F8C
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
0F3A:  BTFSC  x46.7
0F3C:  BRA    0F5C
0F3E:  MOVF   x46,W
0F40:  SUBLW  01
0F42:  BNC   0F8C
0F44:  BNZ   0F5C
0F46:  MOVF   x45,W
0F48:  SUBLW  E1
0F4A:  BNC   0F8C
0F4C:  BNZ   0F5C
0F4E:  MOVF   x44,W
0F50:  SUBLW  33
0F52:  BNC   0F8C
0F54:  BNZ   0F5C
0F56:  MOVF   x43,W
0F58:  SUBLW  7F
0F5A:  BNC   0F8C
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
0F5C:  BCF    FD8.1
0F5E:  MOVFF  146,15B
0F62:  MOVFF  145,15A
0F66:  MOVFF  144,159
0F6A:  MOVFF  143,158
0F6E:  CLRF   x5F
0F70:  MOVLW  01
0F72:  MOVWF  x5E
0F74:  MOVLW  51
0F76:  MOVWF  x5D
0F78:  MOVLW  80
0F7A:  MOVWF  x5C
0F7C:  MOVLB  0
0F7E:  RCALL  085E
0F80:  MOVFF  01,70
0F84:  MOVFF  00,6F
....................             break; 
0F88:  MOVLB  1
0F8A:  BRA    0FD0
....................          } 
....................           
....................          if(isLeapYear) 
0F8C:  BTFSS  x47.1
0F8E:  BRA    0FA2
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
0F90:  MOVLW  00
0F92:  SUBWF  x43,F
0F94:  MOVLW  85
0F96:  SUBWFB x44,F
0F98:  MOVLW  E2
0F9A:  SUBWFB x45,F
0F9C:  MOVLW  01
0F9E:  SUBWFB x46,F
....................          } 
0FA0:  BRA    0FB2
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
0FA2:  MOVLW  80
0FA4:  SUBWF  x43,F
0FA6:  MOVLW  33
0FA8:  SUBWFB x44,F
0FAA:  MOVLW  E1
0FAC:  SUBWFB x45,F
0FAE:  MOVLW  01
0FB0:  SUBWFB x46,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
0FB2:  MOVLB  0
0FB4:  INCF   x6C,F
0FB6:  BTFSC  FD8.2
0FB8:  INCF   x6D,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
0FBA:  MOVFF  6D,14D
0FBE:  MOVFF  6C,14C
0FC2:  CALL   0748
0FC6:  MOVLB  1
0FC8:  BCF    x47.1
0FCA:  BTFSC  01.0
0FCC:  BSF    x47.1
0FCE:  BRA    0EE6
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
0FD0:  MOVLB  0
0FD2:  CLRF   x6B
....................       while(!done) 
0FD4:  MOVLB  1
0FD6:  BTFSC  x47.0
0FD8:  BRA    110A
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
0FDA:  MOVLW  00
0FDC:  BTFSC  x47.1
0FDE:  MOVLW  01
0FE0:  MOVWF  x48
0FE2:  MOVFF  6B,14F
0FE6:  MOVWF  x50
0FE8:  MOVLB  0
0FEA:  RCALL  07FC
0FEC:  MOVFF  FEA,14A
0FF0:  MOVFF  FE9,149
0FF4:  MOVLB  1
0FF6:  CLRF   x53
0FF8:  CLRF   x52
0FFA:  CLRF   x51
0FFC:  MOVFF  01,150
1000:  CLRF   x57
1002:  MOVLW  01
1004:  MOVWF  x56
1006:  MOVLW  51
1008:  MOVWF  x55
100A:  MOVLW  80
100C:  MOVWF  x54
100E:  MOVLB  0
1010:  CALL   06A8
1014:  MOVFF  14A,FEA
1018:  MOVFF  149,FE9
101C:  MOVLB  1
101E:  BTFSC  x46.7
1020:  BRA    1040
1022:  MOVF   x46,W
1024:  SUBWF  03,W
1026:  BNC   1044
1028:  BNZ   1040
102A:  MOVF   x45,W
102C:  SUBWF  02,W
102E:  BNC   1044
1030:  BNZ   1040
1032:  MOVF   x44,W
1034:  SUBWF  01,W
1036:  BNC   1044
1038:  BNZ   1040
103A:  MOVF   00,W
103C:  SUBWF  x43,W
103E:  BC    1044
....................          { 
....................             break; 
1040:  BRA    110A
....................          } 
1042:  BRA    1108
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
1044:  MOVLW  00
1046:  BTFSC  x47.1
1048:  MOVLW  01
104A:  MOVWF  x48
104C:  MOVFF  6B,14F
1050:  MOVWF  x50
1052:  MOVLB  0
1054:  CALL   07FC
1058:  MOVFF  FEA,14A
105C:  MOVFF  FE9,149
1060:  MOVLB  1
1062:  CLRF   x53
1064:  CLRF   x52
1066:  CLRF   x51
1068:  MOVFF  01,150
106C:  CLRF   x57
106E:  MOVLW  01
1070:  MOVWF  x56
1072:  MOVLW  51
1074:  MOVWF  x55
1076:  MOVLW  80
1078:  MOVWF  x54
107A:  MOVLB  0
107C:  CALL   06A8
1080:  MOVFF  14A,FEA
1084:  MOVFF  149,FE9
1088:  MOVLB  1
108A:  BTFSC  x46.7
108C:  BRA    1108
108E:  MOVF   03,W
1090:  SUBWF  x46,W
1092:  BNC   1108
1094:  BNZ   10AC
1096:  MOVF   02,W
1098:  SUBWF  x45,W
109A:  BNC   1108
109C:  BNZ   10AC
109E:  MOVF   01,W
10A0:  SUBWF  x44,W
10A2:  BNC   1108
10A4:  BNZ   10AC
10A6:  MOVF   00,W
10A8:  SUBWF  x43,W
10AA:  BNC   1108
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
10AC:  MOVLW  00
10AE:  BTFSC  x47.1
10B0:  MOVLW  01
10B2:  MOVWF  x48
10B4:  MOVFF  6B,14F
10B8:  MOVWF  x50
10BA:  MOVLB  0
10BC:  CALL   07FC
10C0:  MOVFF  FEA,14A
10C4:  MOVFF  FE9,149
10C8:  MOVLB  1
10CA:  CLRF   x53
10CC:  CLRF   x52
10CE:  CLRF   x51
10D0:  MOVFF  01,150
10D4:  CLRF   x57
10D6:  MOVLW  01
10D8:  MOVWF  x56
10DA:  MOVLW  51
10DC:  MOVWF  x55
10DE:  MOVLW  80
10E0:  MOVWF  x54
10E2:  MOVLB  0
10E4:  CALL   06A8
10E8:  MOVFF  14A,FEA
10EC:  MOVFF  149,FE9
10F0:  MOVF   00,W
10F2:  MOVLB  1
10F4:  SUBWF  x43,F
10F6:  MOVF   01,W
10F8:  SUBWFB x44,F
10FA:  MOVF   02,W
10FC:  SUBWFB x45,F
10FE:  MOVF   03,W
1100:  SUBWFB x46,F
....................             g_lTime.tm_mon++; 
1102:  MOVLB  0
1104:  INCF   x6B,F
1106:  MOVLB  1
....................          } 
1108:  BRA    0FD6
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
110A:  BCF    FD8.1
110C:  MOVFF  146,15B
1110:  MOVFF  145,15A
1114:  MOVFF  144,159
1118:  MOVFF  143,158
111C:  CLRF   x5F
111E:  MOVLW  01
1120:  MOVWF  x5E
1122:  MOVLW  51
1124:  MOVWF  x5D
1126:  MOVLW  80
1128:  MOVWF  x5C
112A:  MOVLB  0
112C:  CALL   085E
1130:  MOVFF  00,6A
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
1134:  MOVLB  1
1136:  CLRF   x53
1138:  CLRF   x52
113A:  CLRF   x51
113C:  MOVFF  6A,150
1140:  CLRF   x57
1142:  MOVLW  01
1144:  MOVWF  x56
1146:  MOVLW  51
1148:  MOVWF  x55
114A:  MOVLW  80
114C:  MOVWF  x54
114E:  MOVLB  0
1150:  CALL   06A8
1154:  MOVF   00,W
1156:  MOVLB  1
1158:  SUBWF  x43,F
115A:  MOVF   01,W
115C:  SUBWFB x44,F
115E:  MOVF   02,W
1160:  SUBWFB x45,F
1162:  MOVF   03,W
1164:  SUBWFB x46,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
1166:  BCF    FD8.1
1168:  MOVFF  146,15B
116C:  MOVFF  145,15A
1170:  MOVFF  144,159
1174:  MOVFF  143,158
1178:  CLRF   x5F
117A:  CLRF   x5E
117C:  MOVLW  0E
117E:  MOVWF  x5D
1180:  MOVLW  10
1182:  MOVWF  x5C
1184:  MOVLB  0
1186:  CALL   085E
118A:  MOVFF  00,69
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
118E:  MOVLB  1
1190:  CLRF   x4B
1192:  CLRF   x4A
1194:  CLRF   x49
1196:  MOVFF  69,148
119A:  MOVFF  14B,153
119E:  MOVFF  14A,152
11A2:  MOVFF  149,151
11A6:  MOVFF  69,150
11AA:  CLRF   x57
11AC:  CLRF   x56
11AE:  MOVLW  0E
11B0:  MOVWF  x55
11B2:  MOVLW  10
11B4:  MOVWF  x54
11B6:  MOVLB  0
11B8:  CALL   06A8
11BC:  MOVF   00,W
11BE:  MOVLB  1
11C0:  SUBWF  x43,F
11C2:  MOVF   01,W
11C4:  SUBWFB x44,F
11C6:  MOVF   02,W
11C8:  SUBWFB x45,F
11CA:  MOVF   03,W
11CC:  SUBWFB x46,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
11CE:  BCF    FD8.1
11D0:  MOVFF  146,15B
11D4:  MOVFF  145,15A
11D8:  MOVFF  144,159
11DC:  MOVFF  143,158
11E0:  CLRF   x5F
11E2:  CLRF   x5E
11E4:  CLRF   x5D
11E6:  MOVLW  3C
11E8:  MOVWF  x5C
11EA:  MOVLB  0
11EC:  CALL   085E
11F0:  MOVFF  00,68
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
11F4:  MOVLB  1
11F6:  CLRF   x49
11F8:  MOVFF  68,148
11FC:  MOVFF  149,14B
1200:  MOVFF  68,14A
1204:  CLRF   x4D
1206:  MOVLW  3C
1208:  MOVWF  x4C
120A:  MOVLB  0
120C:  BRA    0E24
120E:  MOVF   01,W
1210:  MOVLB  1
1212:  SUBWF  x43,F
1214:  MOVF   02,W
1216:  SUBWFB x44,F
1218:  MOVLW  00
121A:  SUBWFB x45,F
121C:  SUBWFB x46,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
121E:  MOVFF  143,67
....................    } 
....................     
....................    return &g_lTime; 
1222:  MOVLW  67
1224:  MOVWF  01
1226:  MOVLW  00
1228:  MOVWF  02
122A:  MOVLB  0
122C:  GOTO   2CC4 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
1AF0:  MOVLB  1
1AF2:  BCF    x5C.0
....................    y = x; 
1AF4:  MOVFF  150,155
1AF8:  MOVFF  14F,154
1AFC:  MOVFF  14E,153
1B00:  MOVFF  14D,152
....................  
....................    if (x < 0) 
1B04:  MOVFF  150,188
1B08:  MOVFF  14F,187
1B0C:  MOVFF  14E,186
1B10:  MOVFF  14D,185
1B14:  CLRF   x8C
1B16:  CLRF   x8B
1B18:  CLRF   x8A
1B1A:  CLRF   x89
1B1C:  MOVLB  0
1B1E:  RCALL  1A3A
1B20:  BNC   1B2E
....................    { 
....................       s = 1; 
1B22:  MOVLB  1
1B24:  BSF    x5C.0
....................       y = -y; 
1B26:  MOVF   x53,W
1B28:  XORLW  80
1B2A:  MOVWF  x53
1B2C:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
1B2E:  MOVFF  155,188
1B32:  MOVFF  154,187
1B36:  MOVFF  153,186
1B3A:  MOVFF  152,185
1B3E:  MOVLB  1
1B40:  CLRF   x8C
1B42:  CLRF   x8B
1B44:  CLRF   x8A
1B46:  MOVLW  8E
1B48:  MOVWF  x89
1B4A:  MOVLB  0
1B4C:  RCALL  1A3A
1B4E:  BC    1B52
1B50:  BNZ   1B80
....................       res = (float32)(unsigned int16)y; 
1B52:  MOVFF  155,188
1B56:  MOVFF  154,187
1B5A:  MOVFF  153,186
1B5E:  MOVFF  152,185
1B62:  RCALL  1AB4
1B64:  MOVFF  02,18A
1B68:  MOVFF  01,189
1B6C:  RCALL  13E0
1B6E:  MOVFF  03,159
1B72:  MOVFF  02,158
1B76:  MOVFF  01,157
1B7A:  MOVFF  00,156
1B7E:  BRA    1D1C
....................  
....................  else if (y < 10000000.0) 
1B80:  MOVFF  155,188
1B84:  MOVFF  154,187
1B88:  MOVFF  153,186
1B8C:  MOVFF  152,185
1B90:  MOVLW  80
1B92:  MOVLB  1
1B94:  MOVWF  x8C
1B96:  MOVLW  96
1B98:  MOVWF  x8B
1B9A:  MOVLW  18
1B9C:  MOVWF  x8A
1B9E:  MOVLW  96
1BA0:  MOVWF  x89
1BA2:  MOVLB  0
1BA4:  RCALL  1A3A
1BA6:  BTFSS  FD8.0
1BA8:  BRA    1D0C
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
1BAA:  MOVFF  155,18C
1BAE:  MOVFF  154,18B
1BB2:  MOVFF  153,18A
1BB6:  MOVFF  152,189
1BBA:  MOVLB  1
1BBC:  CLRF   x90
1BBE:  CLRF   x8F
1BC0:  CLRF   x8E
1BC2:  MOVLW  70
1BC4:  MOVWF  x8D
1BC6:  MOVLB  0
1BC8:  CALL   12EA
1BCC:  MOVFF  03,188
1BD0:  MOVFF  02,187
1BD4:  MOVFF  01,186
1BD8:  MOVFF  00,185
1BDC:  RCALL  1AB4
1BDE:  MOVFF  02,15B
1BE2:  MOVFF  01,15A
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
1BE6:  MOVFF  155,18C
1BEA:  MOVFF  154,18B
1BEE:  MOVFF  153,18A
1BF2:  MOVFF  152,189
1BF6:  MOVLB  1
1BF8:  CLRF   x90
1BFA:  CLRF   x8F
1BFC:  CLRF   x8E
1BFE:  MOVLW  70
1C00:  MOVWF  x8D
1C02:  MOVLB  0
1C04:  CALL   12EA
1C08:  MOVFF  03,160
1C0C:  MOVFF  02,15F
1C10:  MOVFF  01,15E
1C14:  MOVFF  00,15D
1C18:  MOVFF  15B,18A
1C1C:  MOVFF  15A,189
1C20:  CALL   13E0
1C24:  BSF    FD8.1
1C26:  MOVFF  160,18C
1C2A:  MOVFF  15F,18B
1C2E:  MOVFF  15E,18A
1C32:  MOVFF  15D,189
1C36:  MOVFF  03,190
1C3A:  MOVFF  02,18F
1C3E:  MOVFF  01,18E
1C42:  MOVFF  00,18D
1C46:  RCALL  1574
1C48:  MOVLB  1
1C4A:  CLRF   x8C
1C4C:  CLRF   x8B
1C4E:  CLRF   x8A
1C50:  MOVLW  8E
1C52:  MOVWF  x89
1C54:  MOVFF  03,190
1C58:  MOVFF  02,18F
1C5C:  MOVFF  01,18E
1C60:  MOVFF  00,18D
1C64:  MOVLB  0
1C66:  CALL   12EA
1C6A:  MOVFF  03,155
1C6E:  MOVFF  02,154
1C72:  MOVFF  01,153
1C76:  MOVFF  00,152
....................       res = 32768.0*(float32)l; 
1C7A:  MOVFF  15B,18A
1C7E:  MOVFF  15A,189
1C82:  CALL   13E0
1C86:  MOVLB  1
1C88:  CLRF   x8C
1C8A:  CLRF   x8B
1C8C:  CLRF   x8A
1C8E:  MOVLW  8E
1C90:  MOVWF  x89
1C92:  MOVFF  03,190
1C96:  MOVFF  02,18F
1C9A:  MOVFF  01,18E
1C9E:  MOVFF  00,18D
1CA2:  MOVLB  0
1CA4:  CALL   12EA
1CA8:  MOVFF  03,159
1CAC:  MOVFF  02,158
1CB0:  MOVFF  01,157
1CB4:  MOVFF  00,156
....................       res += (float32)(unsigned int16)y; 
1CB8:  MOVFF  155,188
1CBC:  MOVFF  154,187
1CC0:  MOVFF  153,186
1CC4:  MOVFF  152,185
1CC8:  RCALL  1AB4
1CCA:  MOVFF  02,18A
1CCE:  MOVFF  01,189
1CD2:  CALL   13E0
1CD6:  BCF    FD8.1
1CD8:  MOVFF  159,18C
1CDC:  MOVFF  158,18B
1CE0:  MOVFF  157,18A
1CE4:  MOVFF  156,189
1CE8:  MOVFF  03,190
1CEC:  MOVFF  02,18F
1CF0:  MOVFF  01,18E
1CF4:  MOVFF  00,18D
1CF8:  RCALL  1574
1CFA:  MOVFF  03,159
1CFE:  MOVFF  02,158
1D02:  MOVFF  01,157
1D06:  MOVFF  00,156
....................    } 
1D0A:  BRA    1D1C
....................  
....................  else 
....................   res = y; 
1D0C:  MOVFF  155,159
1D10:  MOVFF  154,158
1D14:  MOVFF  153,157
1D18:  MOVFF  152,156
....................  
....................  y = y - (float32)(unsigned int16)y; 
1D1C:  MOVFF  155,188
1D20:  MOVFF  154,187
1D24:  MOVFF  153,186
1D28:  MOVFF  152,185
1D2C:  RCALL  1AB4
1D2E:  MOVFF  02,18A
1D32:  MOVFF  01,189
1D36:  CALL   13E0
1D3A:  BSF    FD8.1
1D3C:  MOVFF  155,18C
1D40:  MOVFF  154,18B
1D44:  MOVFF  153,18A
1D48:  MOVFF  152,189
1D4C:  MOVFF  03,190
1D50:  MOVFF  02,18F
1D54:  MOVFF  01,18E
1D58:  MOVFF  00,18D
1D5C:  RCALL  1574
1D5E:  MOVFF  03,155
1D62:  MOVFF  02,154
1D66:  MOVFF  01,153
1D6A:  MOVFF  00,152
....................  
....................  if (s) 
1D6E:  MOVLB  1
1D70:  BTFSS  x5C.0
1D72:  BRA    1D7A
....................   res = -res; 
1D74:  MOVF   x57,W
1D76:  XORLW  80
1D78:  MOVWF  x57
....................  
....................  if (y != 0) 
1D7A:  MOVFF  155,188
1D7E:  MOVFF  154,187
1D82:  MOVFF  153,186
1D86:  MOVFF  152,185
1D8A:  CLRF   x8C
1D8C:  CLRF   x8B
1D8E:  CLRF   x8A
1D90:  CLRF   x89
1D92:  MOVLB  0
1D94:  RCALL  1A3A
1D96:  BZ    1E10
....................  { 
....................   if (s == 1 && n == 0) 
1D98:  MOVLB  1
1D9A:  BTFSS  x5C.0
1D9C:  BRA    1DD6
1D9E:  MOVF   x51,F
1DA0:  BNZ   1DD6
....................    res -= 1.0; 
1DA2:  BSF    FD8.1
1DA4:  MOVFF  159,18C
1DA8:  MOVFF  158,18B
1DAC:  MOVFF  157,18A
1DB0:  MOVFF  156,189
1DB4:  CLRF   x90
1DB6:  CLRF   x8F
1DB8:  CLRF   x8E
1DBA:  MOVLW  7F
1DBC:  MOVWF  x8D
1DBE:  MOVLB  0
1DC0:  CALL   1574
1DC4:  MOVFF  03,159
1DC8:  MOVFF  02,158
1DCC:  MOVFF  01,157
1DD0:  MOVFF  00,156
1DD4:  MOVLB  1
....................  
....................   if (s == 0 && n == 1) 
1DD6:  BTFSC  x5C.0
1DD8:  BRA    1E12
1DDA:  DECFSZ x51,W
1DDC:  BRA    1E12
....................    res += 1.0; 
1DDE:  BCF    FD8.1
1DE0:  MOVFF  159,18C
1DE4:  MOVFF  158,18B
1DE8:  MOVFF  157,18A
1DEC:  MOVFF  156,189
1DF0:  CLRF   x90
1DF2:  CLRF   x8F
1DF4:  CLRF   x8E
1DF6:  MOVLW  7F
1DF8:  MOVWF  x8D
1DFA:  MOVLB  0
1DFC:  CALL   1574
1E00:  MOVFF  03,159
1E04:  MOVFF  02,158
1E08:  MOVFF  01,157
1E0C:  MOVFF  00,156
1E10:  MOVLB  1
....................  } 
....................  if (x == 0) 
1E12:  MOVFF  150,188
1E16:  MOVFF  14F,187
1E1A:  MOVFF  14E,186
1E1E:  MOVFF  14D,185
1E22:  CLRF   x8C
1E24:  CLRF   x8B
1E26:  CLRF   x8A
1E28:  CLRF   x89
1E2A:  MOVLB  0
1E2C:  RCALL  1A3A
1E2E:  BNZ   1E3C
....................     res = 0; 
1E30:  MOVLB  1
1E32:  CLRF   x59
1E34:  CLRF   x58
1E36:  CLRF   x57
1E38:  CLRF   x56
1E3A:  MOVLB  0
....................  
....................  return (res); 
1E3C:  MOVFF  156,00
1E40:  MOVFF  157,01
1E44:  MOVFF  158,02
1E48:  MOVFF  159,03
1E4C:  GOTO   1E68 (RETURN)
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
1E50:  MOVFF  14C,150
1E54:  MOVFF  14B,14F
1E58:  MOVFF  14A,14E
1E5C:  MOVFF  149,14D
1E60:  MOVLB  1
1E62:  CLRF   x51
1E64:  MOVLB  0
1E66:  BRA    1AF0
1E68:  RETURN 0
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
22F2:  MOVFF  16A,188
22F6:  MOVFF  169,187
22FA:  MOVFF  168,186
22FE:  MOVFF  167,185
2302:  MOVLB  1
2304:  CLRF   x8C
2306:  CLRF   x8B
2308:  CLRF   x8A
230A:  CLRF   x89
230C:  MOVLB  0
230E:  CALL   1A3A
2312:  BC    2316
2314:  BNZ   2320
....................       return(0.0); 
2316:  CLRF   00
2318:  CLRF   01
231A:  CLRF   02
231C:  CLRF   03
231E:  BRA    2416
....................  
....................    y=x; 
2320:  MOVFF  16A,16E
2324:  MOVFF  169,16D
2328:  MOVFF  168,16C
232C:  MOVFF  167,16B
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
2330:  MOVLW  01
2332:  MOVLB  1
2334:  MOVWF  x74
2336:  MOVLW  6B
2338:  MOVWF  x73
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
233A:  MOVFF  173,FE9
233E:  MOVFF  174,FEA
2342:  MOVF   FEF,W
2344:  CLRF   x78
2346:  MOVWF  x77
2348:  MOVLW  7F
234A:  ADDWF  x77,F
234C:  MOVLW  00
234E:  ADDWFC x78,F
2350:  BCF    FD8.0
2352:  RRCF   x78,W
2354:  RRCF   x77,W
2356:  MOVFF  174,FEA
235A:  MOVFF  173,FE9
235E:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
2360:  MOVFF  16E,172
2364:  MOVFF  16D,171
2368:  MOVFF  16C,170
236C:  MOVFF  16B,16F
....................       y+=(x/y); 
2370:  MOVFF  16A,178
2374:  MOVFF  169,177
2378:  MOVFF  168,176
237C:  MOVFF  167,175
2380:  MOVFF  16E,17C
2384:  MOVFF  16D,17B
2388:  MOVFF  16C,17A
238C:  MOVFF  16B,179
2390:  MOVLB  0
2392:  CALL   1416
2396:  BCF    FD8.1
2398:  MOVFF  16E,18C
239C:  MOVFF  16D,18B
23A0:  MOVFF  16C,18A
23A4:  MOVFF  16B,189
23A8:  MOVFF  03,190
23AC:  MOVFF  02,18F
23B0:  MOVFF  01,18E
23B4:  MOVFF  00,18D
23B8:  CALL   1574
23BC:  MOVFF  03,16E
23C0:  MOVFF  02,16D
23C4:  MOVFF  01,16C
23C8:  MOVFF  00,16B
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
23CC:  MOVLB  1
23CE:  MOVFF  173,FE9
23D2:  MOVFF  174,FEA
23D6:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
23D8:  MOVFF  172,188
23DC:  MOVFF  171,187
23E0:  MOVFF  170,186
23E4:  MOVFF  16F,185
23E8:  MOVFF  16E,18C
23EC:  MOVFF  16D,18B
23F0:  MOVFF  16C,18A
23F4:  MOVFF  16B,189
23F8:  MOVLB  0
23FA:  CALL   1A3A
23FE:  BTFSC  FD8.2
2400:  BRA    2406
2402:  MOVLB  1
2404:  BRA    2360
....................  
....................    return(res); 
2406:  MOVFF  16F,00
240A:  MOVFF  170,01
240E:  MOVFF  171,02
2412:  MOVFF  172,03
2416:  GOTO   24F6 (RETURN)
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
*
1E6A:  MOVLB  1
1E6C:  CLRF   x6A
1E6E:  CLRF   x69
1E70:  CLRF   x68
1E72:  MOVLW  7F
1E74:  MOVWF  x67
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
1E76:  MOVLW  7E
1E78:  MOVWF  x71
1E7A:  MOVLW  80
1E7C:  MOVWF  x72
1E7E:  CLRF   x73
1E80:  CLRF   x74
1E82:  MOVLW  7A
1E84:  MOVWF  x75
1E86:  MOVLW  2A
1E88:  MOVWF  x76
1E8A:  MOVLW  AA
1E8C:  MOVWF  x77
1E8E:  MOVLW  A3
1E90:  MOVWF  x78
1E92:  MOVLW  75
1E94:  MOVWF  x79
1E96:  MOVLW  B6
1E98:  MOVWF  x7A
1E9A:  MOVLW  09
1E9C:  MOVWF  x7B
1E9E:  MOVLW  B4
1EA0:  MOVWF  x7C
1EA2:  MOVLW  6F
1EA4:  MOVWF  x7D
1EA6:  MOVLW  4F
1EA8:  MOVWF  x7E
1EAA:  MOVLW  B6
1EAC:  MOVWF  x7F
1EAE:  MOVLW  AA
1EB0:  MOVWF  x80
1EB2:  MOVLW  69
1EB4:  MOVWF  x81
1EB6:  MOVLW  8B
1EB8:  MOVWF  x82
1EBA:  MOVLW  F6
1EBC:  MOVWF  x83
1EBE:  MOVLW  E8
1EC0:  MOVWF  x84
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
1EC2:  MOVFF  15E,188
1EC6:  MOVFF  15D,187
1ECA:  MOVFF  15C,186
1ECE:  MOVFF  15B,185
1ED2:  CLRF   x8C
1ED4:  CLRF   x8B
1ED6:  CLRF   x8A
1ED8:  CLRF   x89
1EDA:  MOVLB  0
1EDC:  RCALL  1A3A
1EDE:  BNC   1EEA
1EE0:  MOVLB  1
1EE2:  MOVF   x5C,W
1EE4:  XORLW  80
1EE6:  MOVWF  x5C
1EE8:  MOVLB  0
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
1EEA:  MOVFF  15E,18C
1EEE:  MOVFF  15D,18B
1EF2:  MOVFF  15C,18A
1EF6:  MOVFF  15B,189
1EFA:  MOVLW  83
1EFC:  MOVLB  1
1EFE:  MOVWF  x90
1F00:  MOVLW  F9
1F02:  MOVWF  x8F
1F04:  MOVLW  22
1F06:  MOVWF  x8E
1F08:  MOVLW  7E
1F0A:  MOVWF  x8D
1F0C:  MOVLB  0
1F0E:  CALL   12EA
1F12:  MOVFF  03,188
1F16:  MOVFF  02,187
1F1A:  MOVFF  01,186
1F1E:  MOVFF  00,185
1F22:  RCALL  1AB4
1F24:  MOVFF  01,16B
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
1F28:  MOVFF  15E,18C
1F2C:  MOVFF  15D,18B
1F30:  MOVFF  15C,18A
1F34:  MOVFF  15B,189
1F38:  MOVLW  83
1F3A:  MOVLB  1
1F3C:  MOVWF  x90
1F3E:  MOVLW  F9
1F40:  MOVWF  x8F
1F42:  MOVLW  22
1F44:  MOVWF  x8E
1F46:  MOVLW  7E
1F48:  MOVWF  x8D
1F4A:  MOVLB  0
1F4C:  CALL   12EA
1F50:  MOVFF  03,188
1F54:  MOVFF  02,187
1F58:  MOVFF  01,186
1F5C:  MOVFF  00,185
1F60:  MOVLB  1
1F62:  CLRF   x8A
1F64:  MOVFF  16B,189
1F68:  MOVLB  0
1F6A:  CALL   13E0
1F6E:  BSF    FD8.1
1F70:  MOVFF  188,18C
1F74:  MOVFF  187,18B
1F78:  MOVFF  186,18A
1F7C:  MOVFF  185,189
1F80:  MOVFF  03,190
1F84:  MOVFF  02,18F
1F88:  MOVFF  01,18E
1F8C:  MOVFF  00,18D
1F90:  CALL   1574
1F94:  MOVFF  03,170
1F98:  MOVFF  02,16F
1F9C:  MOVFF  01,16E
1FA0:  MOVFF  00,16D
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1FA4:  MOVLW  03
1FA6:  MOVLB  1
1FA8:  ANDWF  x6B,F
....................  
....................    if (quad == 0 || quad == 2) 
1FAA:  MOVF   x6B,F
1FAC:  BZ    1FB4
1FAE:  MOVF   x6B,W
1FB0:  SUBLW  02
1FB2:  BNZ   1FEE
....................       t = frac * PI_DIV_BY_TWO; 
1FB4:  MOVFF  170,18C
1FB8:  MOVFF  16F,18B
1FBC:  MOVFF  16E,18A
1FC0:  MOVFF  16D,189
1FC4:  MOVLW  DB
1FC6:  MOVWF  x90
1FC8:  MOVLW  0F
1FCA:  MOVWF  x8F
1FCC:  MOVLW  49
1FCE:  MOVWF  x8E
1FD0:  MOVLW  7F
1FD2:  MOVWF  x8D
1FD4:  MOVLB  0
1FD6:  CALL   12EA
1FDA:  MOVFF  03,166
1FDE:  MOVFF  02,165
1FE2:  MOVFF  01,164
1FE6:  MOVFF  00,163
1FEA:  BRA    20CA
1FEC:  MOVLB  1
....................    else if (quad == 1) 
1FEE:  DECFSZ x6B,W
1FF0:  BRA    2060
....................       t = (1-frac) * PI_DIV_BY_TWO; 
1FF2:  BSF    FD8.1
1FF4:  CLRF   x8C
1FF6:  CLRF   x8B
1FF8:  CLRF   x8A
1FFA:  MOVLW  7F
1FFC:  MOVWF  x89
1FFE:  MOVFF  170,190
2002:  MOVFF  16F,18F
2006:  MOVFF  16E,18E
200A:  MOVFF  16D,18D
200E:  MOVLB  0
2010:  CALL   1574
2014:  MOVFF  03,188
2018:  MOVFF  02,187
201C:  MOVFF  01,186
2020:  MOVFF  00,185
2024:  MOVFF  03,18C
2028:  MOVFF  02,18B
202C:  MOVFF  01,18A
2030:  MOVFF  00,189
2034:  MOVLW  DB
2036:  MOVLB  1
2038:  MOVWF  x90
203A:  MOVLW  0F
203C:  MOVWF  x8F
203E:  MOVLW  49
2040:  MOVWF  x8E
2042:  MOVLW  7F
2044:  MOVWF  x8D
2046:  MOVLB  0
2048:  CALL   12EA
204C:  MOVFF  03,166
2050:  MOVFF  02,165
2054:  MOVFF  01,164
2058:  MOVFF  00,163
205C:  BRA    20CA
205E:  MOVLB  1
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
2060:  BSF    FD8.1
2062:  MOVFF  170,18C
2066:  MOVFF  16F,18B
206A:  MOVFF  16E,18A
206E:  MOVFF  16D,189
2072:  CLRF   x90
2074:  CLRF   x8F
2076:  CLRF   x8E
2078:  MOVLW  7F
207A:  MOVWF  x8D
207C:  MOVLB  0
207E:  CALL   1574
2082:  MOVFF  03,188
2086:  MOVFF  02,187
208A:  MOVFF  01,186
208E:  MOVFF  00,185
2092:  MOVFF  03,18C
2096:  MOVFF  02,18B
209A:  MOVFF  01,18A
209E:  MOVFF  00,189
20A2:  MOVLW  DB
20A4:  MOVLB  1
20A6:  MOVWF  x90
20A8:  MOVLW  0F
20AA:  MOVWF  x8F
20AC:  MOVLW  49
20AE:  MOVWF  x8E
20B0:  MOVLW  7F
20B2:  MOVWF  x8D
20B4:  MOVLB  0
20B6:  CALL   12EA
20BA:  MOVFF  03,166
20BE:  MOVFF  02,165
20C2:  MOVFF  01,164
20C6:  MOVFF  00,163
....................  
....................    y = 1.0; 
20CA:  MOVLB  1
20CC:  CLRF   x62
20CE:  CLRF   x61
20D0:  CLRF   x60
20D2:  MOVLW  7F
20D4:  MOVWF  x5F
....................    t = t * t; 
20D6:  MOVFF  166,18C
20DA:  MOVFF  165,18B
20DE:  MOVFF  164,18A
20E2:  MOVFF  163,189
20E6:  MOVFF  166,190
20EA:  MOVFF  165,18F
20EE:  MOVFF  164,18E
20F2:  MOVFF  163,18D
20F6:  MOVLB  0
20F8:  CALL   12EA
20FC:  MOVFF  03,166
2100:  MOVFF  02,165
2104:  MOVFF  01,164
2108:  MOVFF  00,163
....................    for (i = 0; i <= 4; i++) 
210C:  MOVLB  1
210E:  CLRF   x6C
2110:  MOVF   x6C,W
2112:  SUBLW  04
2114:  BNC   21E2
....................    { 
....................       t2 = t2 * t; 
2116:  MOVFF  16A,18C
211A:  MOVFF  169,18B
211E:  MOVFF  168,18A
2122:  MOVFF  167,189
2126:  MOVFF  166,190
212A:  MOVFF  165,18F
212E:  MOVFF  164,18E
2132:  MOVFF  163,18D
2136:  MOVLB  0
2138:  CALL   12EA
213C:  MOVFF  03,16A
2140:  MOVFF  02,169
2144:  MOVFF  01,168
2148:  MOVFF  00,167
....................       y = y + p[i] * t2; 
214C:  MOVLB  1
214E:  MOVF   x6C,W
2150:  MULLW  04
2152:  MOVF   FF3,W
2154:  CLRF   03
2156:  ADDLW  71
2158:  MOVWF  FE9
215A:  MOVLW  01
215C:  ADDWFC 03,W
215E:  MOVWF  FEA
2160:  MOVFF  FEF,185
2164:  MOVFF  FEC,186
2168:  MOVFF  FEC,187
216C:  MOVFF  FEC,188
2170:  MOVFF  188,18C
2174:  MOVFF  187,18B
2178:  MOVFF  186,18A
217C:  MOVFF  185,189
2180:  MOVFF  16A,190
2184:  MOVFF  169,18F
2188:  MOVFF  168,18E
218C:  MOVFF  167,18D
2190:  MOVLB  0
2192:  CALL   12EA
2196:  MOVFF  FEA,186
219A:  MOVFF  FE9,185
219E:  BCF    FD8.1
21A0:  MOVFF  162,18C
21A4:  MOVFF  161,18B
21A8:  MOVFF  160,18A
21AC:  MOVFF  15F,189
21B0:  MOVFF  03,190
21B4:  MOVFF  02,18F
21B8:  MOVFF  01,18E
21BC:  MOVFF  00,18D
21C0:  CALL   1574
21C4:  MOVFF  186,FEA
21C8:  MOVFF  185,FE9
21CC:  MOVFF  03,162
21D0:  MOVFF  02,161
21D4:  MOVFF  01,160
21D8:  MOVFF  00,15F
21DC:  MOVLB  1
21DE:  INCF   x6C,F
21E0:  BRA    2110
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
21E2:  MOVF   x6B,W
21E4:  SUBLW  02
21E6:  BZ    21EC
21E8:  DECFSZ x6B,W
21EA:  BRA    21F2
....................       y = -y;  // correct sign 
21EC:  MOVF   x60,W
21EE:  XORLW  80
21F0:  MOVWF  x60
....................  
....................    return (y); 
21F2:  MOVFF  15F,00
21F6:  MOVFF  160,01
21FA:  MOVFF  161,02
21FE:  MOVFF  162,03
2202:  MOVLB  0
2204:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
2206:  BSF    FD8.1
2208:  MOVFF  156,18C
220C:  MOVFF  155,18B
2210:  MOVFF  154,18A
2214:  MOVFF  153,189
2218:  MOVLW  DB
221A:  MOVLB  1
221C:  MOVWF  x90
221E:  MOVLW  0F
2220:  MOVWF  x8F
2222:  MOVLW  49
2224:  MOVWF  x8E
2226:  MOVLW  7F
2228:  MOVWF  x8D
222A:  MOVLB  0
222C:  CALL   1574
2230:  MOVFF  03,15A
2234:  MOVFF  02,159
2238:  MOVFF  01,158
223C:  MOVFF  00,157
2240:  MOVFF  03,15E
2244:  MOVFF  02,15D
2248:  MOVFF  01,15C
224C:  MOVFF  00,15B
2250:  RCALL  1E6A
2252:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
2254:  MOVFF  148,15E
2258:  MOVFF  147,15D
225C:  MOVFF  146,15C
2260:  MOVFF  145,15B
2264:  RCALL  1E6A
2266:  MOVFF  03,14C
226A:  MOVFF  02,14B
226E:  MOVFF  01,14A
2272:  MOVFF  00,149
....................    if (c == 0.0) 
2276:  MOVFF  14C,188
227A:  MOVFF  14B,187
227E:  MOVFF  14A,186
2282:  MOVFF  149,185
2286:  MOVLB  1
2288:  CLRF   x8C
228A:  CLRF   x8B
228C:  CLRF   x8A
228E:  CLRF   x89
2290:  MOVLB  0
2292:  CALL   1A3A
2296:  BNZ   22AA
....................       return (1.0e+36); 
2298:  MOVLW  F6
229A:  MOVWF  00
229C:  MOVLW  40
229E:  MOVWF  01
22A0:  MOVLW  97
22A2:  MOVWF  02
22A4:  MOVLW  CE
22A6:  MOVWF  03
22A8:  BRA    22F0
....................  
....................    s = sin(x); 
22AA:  MOVFF  148,156
22AE:  MOVFF  147,155
22B2:  MOVFF  146,154
22B6:  MOVFF  145,153
22BA:  RCALL  2206
22BC:  MOVFF  03,150
22C0:  MOVFF  02,14F
22C4:  MOVFF  01,14E
22C8:  MOVFF  00,14D
....................    return(s/c); 
22CC:  MOVFF  150,178
22D0:  MOVFF  14F,177
22D4:  MOVFF  14E,176
22D8:  MOVFF  14D,175
22DC:  MOVFF  14C,17C
22E0:  MOVFF  14B,17B
22E4:  MOVFF  14A,17A
22E8:  MOVFF  149,179
22EC:  CALL   1416
22F0:  RETURN 0
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
*
241A:  MOVLB  1
241C:  BCF    x62.0
....................    y = x; 
241E:  MOVFF  150,155
2422:  MOVFF  14F,154
2426:  MOVFF  14E,153
242A:  MOVFF  14D,152
....................  
....................    if (x < 0) 
242E:  MOVFF  150,188
2432:  MOVFF  14F,187
2436:  MOVFF  14E,186
243A:  MOVFF  14D,185
243E:  CLRF   x8C
2440:  CLRF   x8B
2442:  CLRF   x8A
2444:  CLRF   x89
2446:  MOVLB  0
2448:  CALL   1A3A
244C:  BNC   245A
....................    { 
....................       s = 1; 
244E:  MOVLB  1
2450:  BSF    x62.0
....................       y = -y; 
2452:  MOVF   x53,W
2454:  XORLW  80
2456:  MOVWF  x53
2458:  MOVLB  0
....................    } 
....................  
....................    if (y > 0.5) 
245A:  MOVLB  1
245C:  CLRF   x88
245E:  CLRF   x87
2460:  CLRF   x86
2462:  MOVLW  7E
2464:  MOVWF  x85
2466:  MOVFF  155,18C
246A:  MOVFF  154,18B
246E:  MOVFF  153,18A
2472:  MOVFF  152,189
2476:  MOVLB  0
2478:  CALL   1A3A
247C:  BNC   250E
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
247E:  BSF    FD8.1
2480:  MOVLB  1
2482:  CLRF   x8C
2484:  CLRF   x8B
2486:  CLRF   x8A
2488:  MOVLW  7F
248A:  MOVWF  x89
248C:  MOVFF  155,190
2490:  MOVFF  154,18F
2494:  MOVFF  153,18E
2498:  MOVFF  152,18D
249C:  MOVLB  0
249E:  CALL   1574
24A2:  MOVFF  03,166
24A6:  MOVFF  02,165
24AA:  MOVFF  01,164
24AE:  MOVFF  00,163
24B2:  MOVFF  03,18C
24B6:  MOVFF  02,18B
24BA:  MOVFF  01,18A
24BE:  MOVFF  00,189
24C2:  MOVLB  1
24C4:  CLRF   x90
24C6:  CLRF   x8F
24C8:  CLRF   x8E
24CA:  MOVLW  7E
24CC:  MOVWF  x8D
24CE:  MOVLB  0
24D0:  CALL   12EA
24D4:  MOVFF  03,166
24D8:  MOVFF  02,165
24DC:  MOVFF  01,164
24E0:  MOVFF  00,163
24E4:  MOVFF  03,16A
24E8:  MOVFF  02,169
24EC:  MOVFF  01,168
24F0:  MOVFF  00,167
24F4:  BRA    22F2
24F6:  MOVFF  03,155
24FA:  MOVFF  02,154
24FE:  MOVFF  01,153
2502:  MOVFF  00,152
....................       n += 2; 
2506:  MOVLW  02
2508:  MOVLB  1
250A:  ADDWF  x51,F
250C:  MOVLB  0
....................    } 
....................  
....................    y2=y*y; 
250E:  MOVFF  155,18C
2512:  MOVFF  154,18B
2516:  MOVFF  153,18A
251A:  MOVFF  152,189
251E:  MOVFF  155,190
2522:  MOVFF  154,18F
2526:  MOVFF  153,18E
252A:  MOVFF  152,18D
252E:  CALL   12EA
2532:  MOVFF  03,161
2536:  MOVFF  02,160
253A:  MOVFF  01,15F
253E:  MOVFF  00,15E
....................  
....................    res = pas[0]*y2 + pas[1]; 
2542:  MOVLW  37
2544:  MOVLB  1
2546:  MOVWF  x8C
2548:  MOVLW  BF
254A:  MOVWF  x8B
254C:  MOVLW  7D
254E:  MOVWF  x8A
2550:  MOVWF  x89
2552:  MOVFF  161,190
2556:  MOVFF  160,18F
255A:  MOVFF  15F,18E
255E:  MOVFF  15E,18D
2562:  MOVLB  0
2564:  CALL   12EA
2568:  MOVFF  03,166
256C:  MOVFF  02,165
2570:  MOVFF  01,164
2574:  MOVFF  00,163
2578:  BCF    FD8.1
257A:  MOVFF  03,18C
257E:  MOVFF  02,18B
2582:  MOVFF  01,18A
2586:  MOVFF  00,189
258A:  MOVLW  3D
258C:  MOVLB  1
258E:  MOVWF  x90
2590:  MOVLW  AA
2592:  MOVWF  x8F
2594:  MOVLW  93
2596:  MOVWF  x8E
2598:  MOVLW  81
259A:  MOVWF  x8D
259C:  MOVLB  0
259E:  CALL   1574
25A2:  MOVFF  03,159
25A6:  MOVFF  02,158
25AA:  MOVFF  01,157
25AE:  MOVFF  00,156
....................    res = res*y2 + pas[2]; 
25B2:  MOVFF  159,18C
25B6:  MOVFF  158,18B
25BA:  MOVFF  157,18A
25BE:  MOVFF  156,189
25C2:  MOVFF  161,190
25C6:  MOVFF  160,18F
25CA:  MOVFF  15F,18E
25CE:  MOVFF  15E,18D
25D2:  CALL   12EA
25D6:  MOVFF  03,166
25DA:  MOVFF  02,165
25DE:  MOVFF  01,164
25E2:  MOVFF  00,163
25E6:  BCF    FD8.1
25E8:  MOVFF  03,18C
25EC:  MOVFF  02,18B
25F0:  MOVFF  01,18A
25F4:  MOVFF  00,189
25F8:  MOVLW  EE
25FA:  MOVLB  1
25FC:  MOVWF  x90
25FE:  MOVLW  50
2600:  MOVWF  x8F
2602:  MOVLW  33
2604:  MOVWF  x8E
2606:  MOVLW  81
2608:  MOVWF  x8D
260A:  MOVLB  0
260C:  CALL   1574
2610:  MOVFF  03,159
2614:  MOVFF  02,158
2618:  MOVFF  01,157
261C:  MOVFF  00,156
....................  
....................    r = qas[0]*y2 + qas[1]; 
2620:  MOVLB  1
2622:  CLRF   x8C
2624:  CLRF   x8B
2626:  CLRF   x8A
2628:  MOVLW  7F
262A:  MOVWF  x89
262C:  MOVFF  161,190
2630:  MOVFF  160,18F
2634:  MOVFF  15F,18E
2638:  MOVFF  15E,18D
263C:  MOVLB  0
263E:  CALL   12EA
2642:  MOVFF  03,166
2646:  MOVFF  02,165
264A:  MOVFF  01,164
264E:  MOVFF  00,163
2652:  BCF    FD8.1
2654:  MOVFF  03,18C
2658:  MOVFF  02,18B
265C:  MOVFF  01,18A
2660:  MOVFF  00,189
2664:  MOVLW  0A
2666:  MOVLB  1
2668:  MOVWF  x90
266A:  MOVLW  8D
266C:  MOVWF  x8F
266E:  MOVLW  B1
2670:  MOVWF  x8E
2672:  MOVLW  81
2674:  MOVWF  x8D
2676:  MOVLB  0
2678:  CALL   1574
267C:  MOVFF  03,15D
2680:  MOVFF  02,15C
2684:  MOVFF  01,15B
2688:  MOVFF  00,15A
....................    r = r*y2 + qas[2]; 
268C:  MOVFF  15D,18C
2690:  MOVFF  15C,18B
2694:  MOVFF  15B,18A
2698:  MOVFF  15A,189
269C:  MOVFF  161,190
26A0:  MOVFF  160,18F
26A4:  MOVFF  15F,18E
26A8:  MOVFF  15E,18D
26AC:  CALL   12EA
26B0:  MOVFF  03,166
26B4:  MOVFF  02,165
26B8:  MOVFF  01,164
26BC:  MOVFF  00,163
26C0:  BCF    FD8.1
26C2:  MOVFF  03,18C
26C6:  MOVFF  02,18B
26CA:  MOVFF  01,18A
26CE:  MOVFF  00,189
26D2:  MOVLW  EE
26D4:  MOVLB  1
26D6:  MOVWF  x90
26D8:  MOVLW  50
26DA:  MOVWF  x8F
26DC:  MOVLW  33
26DE:  MOVWF  x8E
26E0:  MOVLW  81
26E2:  MOVWF  x8D
26E4:  MOVLB  0
26E6:  CALL   1574
26EA:  MOVFF  03,15D
26EE:  MOVFF  02,15C
26F2:  MOVFF  01,15B
26F6:  MOVFF  00,15A
....................  
....................    res = y*res/r; 
26FA:  MOVFF  155,18C
26FE:  MOVFF  154,18B
2702:  MOVFF  153,18A
2706:  MOVFF  152,189
270A:  MOVFF  159,190
270E:  MOVFF  158,18F
2712:  MOVFF  157,18E
2716:  MOVFF  156,18D
271A:  CALL   12EA
271E:  MOVFF  03,166
2722:  MOVFF  02,165
2726:  MOVFF  01,164
272A:  MOVFF  00,163
272E:  MOVFF  03,178
2732:  MOVFF  02,177
2736:  MOVFF  01,176
273A:  MOVFF  00,175
273E:  MOVFF  15D,17C
2742:  MOVFF  15C,17B
2746:  MOVFF  15B,17A
274A:  MOVFF  15A,179
274E:  CALL   1416
2752:  MOVFF  03,159
2756:  MOVFF  02,158
275A:  MOVFF  01,157
275E:  MOVFF  00,156
....................  
....................    if (n & 2)     // |x| > 0.5 
2762:  MOVLB  1
2764:  BTFSS  x51.1
2766:  BRA    27C4
....................       res = PI_DIV_BY_TWO - 2.0*res; 
2768:  CLRF   x8C
276A:  CLRF   x8B
276C:  CLRF   x8A
276E:  MOVLW  80
2770:  MOVWF  x89
2772:  MOVFF  159,190
2776:  MOVFF  158,18F
277A:  MOVFF  157,18E
277E:  MOVFF  156,18D
2782:  MOVLB  0
2784:  CALL   12EA
2788:  BSF    FD8.1
278A:  MOVLW  DB
278C:  MOVLB  1
278E:  MOVWF  x8C
2790:  MOVLW  0F
2792:  MOVWF  x8B
2794:  MOVLW  49
2796:  MOVWF  x8A
2798:  MOVLW  7F
279A:  MOVWF  x89
279C:  MOVFF  03,190
27A0:  MOVFF  02,18F
27A4:  MOVFF  01,18E
27A8:  MOVFF  00,18D
27AC:  MOVLB  0
27AE:  CALL   1574
27B2:  MOVFF  03,159
27B6:  MOVFF  02,158
27BA:  MOVFF  01,157
27BE:  MOVFF  00,156
27C2:  MOVLB  1
....................    if (s) 
27C4:  BTFSS  x62.0
27C6:  BRA    27CE
....................       res = -res; 
27C8:  MOVF   x57,W
27CA:  XORLW  80
27CC:  MOVWF  x57
....................    if (n & 1)           // take arccos 
27CE:  BTFSS  x51.0
27D0:  BRA    280C
....................       res = PI_DIV_BY_TWO - res; 
27D2:  BSF    FD8.1
27D4:  MOVLW  DB
27D6:  MOVWF  x8C
27D8:  MOVLW  0F
27DA:  MOVWF  x8B
27DC:  MOVLW  49
27DE:  MOVWF  x8A
27E0:  MOVLW  7F
27E2:  MOVWF  x89
27E4:  MOVFF  159,190
27E8:  MOVFF  158,18F
27EC:  MOVFF  157,18E
27F0:  MOVFF  156,18D
27F4:  MOVLB  0
27F6:  CALL   1574
27FA:  MOVFF  03,159
27FE:  MOVFF  02,158
2802:  MOVFF  01,157
2806:  MOVFF  00,156
280A:  MOVLB  1
....................  
....................    return(res); 
280C:  MOVFF  156,00
2810:  MOVFF  157,01
2814:  MOVFF  158,02
2818:  MOVFF  159,03
281C:  MOVLB  0
281E:  GOTO   283C (RETURN)
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
2822:  MOVFF  148,150
2826:  MOVFF  147,14F
282A:  MOVFF  146,14E
282E:  MOVFF  145,14D
2832:  MOVLW  01
2834:  MOVLB  1
2836:  MOVWF  x51
2838:  MOVLB  0
283A:  BRA    241A
283C:  MOVFF  03,14C
2840:  MOVFF  02,14B
2844:  MOVFF  01,14A
2848:  MOVFF  00,149
....................    return(r); 
284C:  MOVFF  149,00
2850:  MOVFF  14A,01
2854:  MOVFF  14B,02
2858:  MOVFF  14C,03
285C:  RETURN 0
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... float lat,lon,eti,dec1,to,ws,tc1,orto,horapuesta,horaorto; 
.................... float horaocaso,horareal,ocaso,horasalida,tst,azimut,ha; 
.................... float zenit,haa, da1, N1, N2, N3, adia1; 
.................... float hor, min, sec, horare; 
.................... float hora,minutos,segundos,x,dia,mes,year; 
.................... //variable para la libreria de fechas  
.................... time_t unix_time; 
.................... struct_tm utc_time, *my_time; 
.................... // other variables 
.................... char time_c[] = "HORA:   :  :  "; 
.................... char date_c[] = "FECHA:    -  -20  "; 
....................  
.................... char datee_c[] = "  ";  //MES 
.................... char dia_c[] = "  ";    //DIA 
.................... char ano_c[] ="  ";     //AO 
.................... char hora_c[]="  ";     //HORA 
.................... char min_c[]="  ";      //MINUTOS 
.................... char seg_c[]="  ";      //SEGUNDOS 
.................... void print_wday(int8 wday){ 
....................   lcd_gotoxy(6, 1); 
*
1230:  MOVLW  06
1232:  MOVLB  1
1234:  MOVWF  x4F
1236:  MOVLW  01
1238:  MOVWF  x50
123A:  MOVLB  0
123C:  CALL   025C
....................   switch(wday){ 
1240:  MOVLB  1
1242:  MOVF   x42,W
1244:  XORLW  00
1246:  MOVLB  0
1248:  BZ    1260
124A:  XORLW  01
124C:  BZ    126E
124E:  XORLW  03
1250:  BZ    127C
1252:  XORLW  01
1254:  BZ    128A
1256:  XORLW  07
1258:  BZ    1298
125A:  XORLW  01
125C:  BZ    12A6
125E:  BRA    12B4
....................     case 0:  lcd_putc(" DOMINGO  ");  break; 
1260:  MOVLW  04
1262:  MOVWF  FF6
1264:  MOVLW  00
1266:  MOVWF  FF7
1268:  CALL   02EE
126C:  BRA    12C0
....................     case 1:  lcd_putc(" LUNES  ");    break; 
126E:  MOVLW  10
1270:  MOVWF  FF6
1272:  MOVLW  00
1274:  MOVWF  FF7
1276:  CALL   02EE
127A:  BRA    12C0
....................     case 2:  lcd_putc(" MARTES ");    break; 
127C:  MOVLW  1A
127E:  MOVWF  FF6
1280:  MOVLW  00
1282:  MOVWF  FF7
1284:  CALL   02EE
1288:  BRA    12C0
....................     case 3:  lcd_putc("MIERCOLES");   break; 
128A:  MOVLW  24
128C:  MOVWF  FF6
128E:  MOVLW  00
1290:  MOVWF  FF7
1292:  CALL   02EE
1296:  BRA    12C0
....................     case 4:  lcd_putc("JUEVES ");     break; 
1298:  MOVLW  2E
129A:  MOVWF  FF6
129C:  MOVLW  00
129E:  MOVWF  FF7
12A0:  CALL   02EE
12A4:  BRA    12C0
....................     case 5:  lcd_putc(" VIERNES  ");  break; 
12A6:  MOVLW  36
12A8:  MOVWF  FF6
12AA:  MOVLW  00
12AC:  MOVWF  FF7
12AE:  CALL   02EE
12B2:  BRA    12C0
....................     default: lcd_putc("SABADO "); 
12B4:  MOVLW  42
12B6:  MOVWF  FF6
12B8:  MOVLW  00
12BA:  MOVWF  FF7
12BC:  CALL   02EE
....................   } 
12C0:  GOTO   3050 (RETURN)
....................   
.................... } 
.................... void main(void) { //PROGRAMA PRINCIPAL 
*
2B10:  CLRF   FF8
2B12:  BCF    FD0.7
2B14:  MOVLW  70
2B16:  MOVWF  FD3
2B18:  MOVF   FD3,W
2B1A:  CLRF   04
2B1C:  BCF    FB8.3
2B1E:  MOVLW  0C
2B20:  MOVWF  FAF
2B22:  MOVLW  A2
2B24:  MOVWF  FAC
2B26:  MOVLW  90
2B28:  MOVWF  FAB
2B2A:  BCF    0B.0
2B2C:  BCF    0B.1
2B2E:  CLRF   0C
2B30:  CLRF   0D
2B32:  CLRF   x66
2B34:  CLRF   x65
2B36:  MOVF   FC1,W
2B38:  ANDLW  C0
2B3A:  IORLW  0F
2B3C:  MOVWF  FC1
2B3E:  MOVLW  07
2B40:  MOVWF  FB4
2B42:  MOVLW  01
2B44:  MOVWF  x64
2B46:  MOVLW  99
2B48:  MOVWF  x63
2B4A:  MOVLW  06
2B4C:  MOVLB  1
2B4E:  MOVWF  x9A
2B50:  MOVLW  63
2B52:  MOVWF  x99
2B54:  CLRF   x9C
2B56:  CLRF   x9B
2B58:  MOVLB  0
2B5A:  BRA    2B9A
2B5C:  DATA 02,00
2B5E:  DATA 05,00
2B60:  DATA 00,15
2B62:  DATA 01,0D
2B64:  DATA 48,4F
2B66:  DATA 52,41
2B68:  DATA 3A,20
2B6A:  DATA 20,20
2B6C:  DATA 3A,20
2B6E:  DATA 20,3A
2B70:  DATA 20,20
2B72:  DATA 00,46
2B74:  DATA 45,43
2B76:  DATA 48,41
2B78:  DATA 3A,04
2B7A:  DATA C0,20
2B7C:  DATA 1B,80
2B7E:  DATA 2D,20
2B80:  DATA 20,2D
2B82:  DATA 32,30
2B84:  DATA 20,20
2B86:  DATA 00,20
2B88:  DATA 20,00
2B8A:  DATA 20,20
2B8C:  DATA 00,20
2B8E:  DATA 20,00
2B90:  DATA 20,20
2B92:  DATA 00,20
2B94:  DATA 20,00
2B96:  DATA 20,20
2B98:  DATA 00,00
2B9A:  MOVLW  00
2B9C:  MOVWF  FF8
2B9E:  MOVLW  2B
2BA0:  MOVWF  FF7
2BA2:  MOVLW  5C
2BA4:  MOVWF  FF6
2BA6:  TBLRD*+
2BA8:  MOVF   FF5,W
2BAA:  MOVWF  00
2BAC:  XORLW  00
2BAE:  BZ    2BD6
2BB0:  TBLRD*+
2BB2:  MOVF   FF5,W
2BB4:  MOVWF  01
2BB6:  BTFSC  FE8.7
2BB8:  BRA    2BC4
2BBA:  ANDLW  0F
2BBC:  MOVWF  FEA
2BBE:  TBLRD*+
2BC0:  MOVF   FF5,W
2BC2:  MOVWF  FE9
2BC4:  BTFSC  01.6
2BC6:  TBLRD*+
2BC8:  BTFSS  01.6
2BCA:  TBLRD*+
2BCC:  MOVF   FF5,W
2BCE:  MOVWF  FEE
2BD0:  DCFSNZ 00,F
2BD2:  BRA    2BA6
2BD4:  BRA    2BC8
2BD6:  CLRF   FF8
....................   setup_oscillator(OSC_8MHZ);                // Set internal oscillator to 8MHz 
2BD8:  MOVLW  70
2BDA:  MOVWF  FD3
2BDC:  MOVF   FD3,W
....................   lcd_init(); 
2BDE:  GOTO   01C6
....................   delay_ms(50); 
2BE2:  MOVLW  32
2BE4:  MOVLB  1
2BE6:  MOVWF  x4F
2BE8:  MOVLB  0
2BEA:  CALL   008A
....................   printf(lcd_putc,"INICIANDO SISTEMA \n  ESPERE...."); 
2BEE:  MOVLW  4A
2BF0:  MOVWF  FF6
2BF2:  MOVLW  00
2BF4:  MOVWF  FF7
2BF6:  CALL   02EE
....................   delay_ms(2000); 
2BFA:  MOVLW  08
2BFC:  MOVLB  1
2BFE:  MOVWF  x41
2C00:  MOVLW  FA
2C02:  MOVWF  x4F
2C04:  MOVLB  0
2C06:  CALL   008A
2C0A:  MOVLB  1
2C0C:  DECFSZ x41,F
2C0E:  BRA    2C00
....................   lcd_putc("\f"); 
2C10:  MOVLW  6A
2C12:  MOVWF  FF6
2C14:  MOVLW  00
2C16:  MOVWF  FF7
2C18:  MOVLB  0
2C1A:  CALL   02EE
....................   while(TRUE){ 
....................     if(kbhit()){ 
2C1E:  BTFSS  F9E.5
2C20:  GOTO   4B92
....................       if(GPSRead()){ 
2C24:  GOTO   03EA
2C28:  MOVF   01,F
2C2A:  BTFSC  FD8.2
2C2C:  GOTO   4B92
....................         //configura la posicion gps  
....................         lat = 19.0506 ; 
2C30:  MOVLW  A1
2C32:  MOVWF  x74
2C34:  MOVLW  67
2C36:  MOVWF  x73
2C38:  MOVLW  18
2C3A:  MOVWF  x72
2C3C:  MOVLW  83
2C3E:  MOVWF  x71
....................         lon = -104.316; 
2C40:  MOVLW  CB
2C42:  MOVWF  x78
2C44:  MOVLW  A1
2C46:  MOVWF  x77
2C48:  MOVLW  D0
2C4A:  MOVWF  x76
2C4C:  MOVLW  85
2C4E:  MOVWF  x75
....................         //lee y guarda las hora y fecha en formato UTC 
....................         utc_time.tm_hour = GPSHour(); 
2C50:  GOTO   060C
2C54:  MOVFF  01,103
....................         utc_time.tm_min  = GPSMinute(); 
2C58:  GOTO   0626
2C5C:  MOVFF  01,102
....................         utc_time.tm_sec  = GPSSecond(); 
2C60:  GOTO   0640
2C64:  MOVFF  01,101
....................         //ajusta las valores a un formato compatible  
....................         utc_time.tm_mday = GPSDay();          //numero de dia del mes en formato (1 - 31) 
2C68:  GOTO   065A
2C6C:  MOVFF  01,104
....................         utc_time.tm_mon  = GPSMonth() - 1;    //numero del mes en formato (0 - 11) 
2C70:  GOTO   0674
2C74:  MOVLW  01
2C76:  SUBWF  01,W
2C78:  MOVLB  1
2C7A:  MOVWF  x05
....................         utc_time.tm_year = GPSYear() + 100;   //Ao iniciando desde 1900 
2C7C:  MOVLB  0
2C7E:  GOTO   068E
2C82:  MOVLW  64
2C84:  ADDWF  01,W
2C86:  MOVLB  1
2C88:  MOVWF  x06
2C8A:  CLRF   x07
....................         //obtiene las fechas de unix  
....................         unix_time = mktime(&utc_time);  
2C8C:  MOVLW  01
2C8E:  MOVWF  x42
2C90:  MOVWF  x41
2C92:  MOVLB  0
2C94:  GOTO   0948
2C98:  MOVFF  03,100
2C9C:  MOVFF  02,FF
2CA0:  MOVFF  01,FE
2CA4:  MOVFF  00,FD
....................         //aade los segundos al formato unix  
....................         unix_time += time_offset;  
2CA8:  MOVLW  B0
2CAA:  ADDWF  xFD,F
2CAC:  MOVLW  B9
2CAE:  ADDWFC xFE,F
2CB0:  MOVLW  FF
2CB2:  ADDWFC xFF,F
2CB4:  MOVLB  1
2CB6:  ADDWFC x00,F
....................         //obtiene la hora local segun la posicion GPS  
....................         my_time = localtime(&unix_time);  
2CB8:  CLRF   x42
2CBA:  MOVLW  FD
2CBC:  MOVWF  x41
2CBE:  MOVLB  0
2CC0:  GOTO   0E48
2CC4:  MOVFF  02,10C
2CC8:  MOVFF  01,10B
....................         time_c[6]   = my_time->tm_hour / 10 + '0'; 
2CCC:  MOVLW  02
2CCE:  MOVLB  1
2CD0:  ADDWF  x0B,W
2CD2:  MOVWF  FE9
2CD4:  MOVLW  00
2CD6:  ADDWFC x0C,W
2CD8:  MOVWF  FEA
2CDA:  MOVFF  FEF,14D
2CDE:  MOVLW  0A
2CE0:  MOVWF  x4E
2CE2:  MOVLB  0
2CE4:  CALL   07D0
2CE8:  MOVLW  30
2CEA:  ADDWF  01,W
2CEC:  MOVLB  1
2CEE:  MOVWF  x13
....................         time_c[7]   = my_time->tm_hour % 10 + '0'; 
2CF0:  MOVLW  02
2CF2:  ADDWF  x0B,W
2CF4:  MOVWF  FE9
2CF6:  MOVLW  00
2CF8:  ADDWFC x0C,W
2CFA:  MOVWF  FEA
2CFC:  MOVFF  FEF,14D
2D00:  MOVLW  0A
2D02:  MOVWF  x4E
2D04:  MOVLB  0
2D06:  CALL   07D0
2D0A:  MOVLW  30
2D0C:  ADDWF  00,W
2D0E:  MOVLB  1
2D10:  MOVWF  x14
....................         time_c[9]   = my_time->tm_min  / 10 + '0'; 
2D12:  MOVLW  01
2D14:  ADDWF  x0B,W
2D16:  MOVWF  FE9
2D18:  MOVLW  00
2D1A:  ADDWFC x0C,W
2D1C:  MOVWF  FEA
2D1E:  MOVFF  FEF,14D
2D22:  MOVLW  0A
2D24:  MOVWF  x4E
2D26:  MOVLB  0
2D28:  CALL   07D0
2D2C:  MOVLW  30
2D2E:  ADDWF  01,W
2D30:  MOVLB  1
2D32:  MOVWF  x16
....................         time_c[10]  = my_time->tm_min  % 10 + '0'; 
2D34:  MOVLW  01
2D36:  ADDWF  x0B,W
2D38:  MOVWF  FE9
2D3A:  MOVLW  00
2D3C:  ADDWFC x0C,W
2D3E:  MOVWF  FEA
2D40:  MOVFF  FEF,14D
2D44:  MOVLW  0A
2D46:  MOVWF  x4E
2D48:  MOVLB  0
2D4A:  CALL   07D0
2D4E:  MOVLW  30
2D50:  ADDWF  00,W
2D52:  MOVLB  1
2D54:  MOVWF  x17
....................         time_c[12]  = my_time->tm_sec  / 10 + '0'; 
2D56:  MOVFF  10B,FE9
2D5A:  MOVFF  10C,FEA
2D5E:  MOVFF  FEF,14D
2D62:  MOVLW  0A
2D64:  MOVWF  x4E
2D66:  MOVLB  0
2D68:  CALL   07D0
2D6C:  MOVLW  30
2D6E:  ADDWF  01,W
2D70:  MOVLB  1
2D72:  MOVWF  x19
....................         time_c[13]  = my_time->tm_sec  % 10 + '0';         
2D74:  MOVFF  10B,FE9
2D78:  MOVFF  10C,FEA
2D7C:  MOVFF  FEF,14D
2D80:  MOVLW  0A
2D82:  MOVWF  x4E
2D84:  MOVLB  0
2D86:  CALL   07D0
2D8A:  MOVLW  30
2D8C:  ADDWF  00,W
2D8E:  MOVLB  1
2D90:  MOVWF  x1A
....................         hora_c[1]   = my_time->tm_hour / 10 + '0'; 
2D92:  MOVLW  02
2D94:  ADDWF  x0B,W
2D96:  MOVWF  FE9
2D98:  MOVLW  00
2D9A:  ADDWFC x0C,W
2D9C:  MOVWF  FEA
2D9E:  MOVFF  FEF,14D
2DA2:  MOVLW  0A
2DA4:  MOVWF  x4E
2DA6:  MOVLB  0
2DA8:  CALL   07D0
2DAC:  MOVLW  30
2DAE:  ADDWF  01,W
2DB0:  MOVLB  1
2DB2:  MOVWF  x39
....................         hora_c[2]   = my_time->tm_hour % 10 + '0';         
2DB4:  MOVLW  02
2DB6:  ADDWF  x0B,W
2DB8:  MOVWF  FE9
2DBA:  MOVLW  00
2DBC:  ADDWFC x0C,W
2DBE:  MOVWF  FEA
2DC0:  MOVFF  FEF,14D
2DC4:  MOVLW  0A
2DC6:  MOVWF  x4E
2DC8:  MOVLB  0
2DCA:  CALL   07D0
2DCE:  MOVLW  30
2DD0:  ADDWF  00,W
2DD2:  MOVLB  1
2DD4:  MOVWF  x3A
....................         min_c[1]    = my_time->tm_min  / 10 + '0'; 
2DD6:  MOVLW  01
2DD8:  ADDWF  x0B,W
2DDA:  MOVWF  FE9
2DDC:  MOVLW  00
2DDE:  ADDWFC x0C,W
2DE0:  MOVWF  FEA
2DE2:  MOVFF  FEF,14D
2DE6:  MOVLW  0A
2DE8:  MOVWF  x4E
2DEA:  MOVLB  0
2DEC:  CALL   07D0
2DF0:  MOVLW  30
2DF2:  ADDWF  01,W
2DF4:  MOVLB  1
2DF6:  MOVWF  x3C
....................         min_c[2]    = my_time->tm_min  % 10 + '0'; 
2DF8:  MOVLW  01
2DFA:  ADDWF  x0B,W
2DFC:  MOVWF  FE9
2DFE:  MOVLW  00
2E00:  ADDWFC x0C,W
2E02:  MOVWF  FEA
2E04:  MOVFF  FEF,14D
2E08:  MOVLW  0A
2E0A:  MOVWF  x4E
2E0C:  MOVLB  0
2E0E:  CALL   07D0
2E12:  MOVLW  30
2E14:  ADDWF  00,W
2E16:  MOVLB  1
2E18:  MOVWF  x3D
....................         seg_c[1]    = my_time->tm_sec  / 10 + '0'; 
2E1A:  MOVFF  10B,FE9
2E1E:  MOVFF  10C,FEA
2E22:  MOVFF  FEF,14D
2E26:  MOVLW  0A
2E28:  MOVWF  x4E
2E2A:  MOVLB  0
2E2C:  CALL   07D0
2E30:  MOVLW  30
2E32:  ADDWF  01,W
2E34:  MOVLB  1
2E36:  MOVWF  x3F
....................         seg_c[2]    = my_time->tm_sec  % 10 + '0';         
2E38:  MOVFF  10B,FE9
2E3C:  MOVFF  10C,FEA
2E40:  MOVFF  FEF,14D
2E44:  MOVLW  0A
2E46:  MOVWF  x4E
2E48:  MOVLB  0
2E4A:  CALL   07D0
2E4E:  MOVLW  30
2E50:  ADDWF  00,W
2E52:  MOVLB  1
2E54:  MOVWF  x40
....................         date_c[6]   = my_time->tm_mday / 10 + '0'; 
2E56:  MOVLW  03
2E58:  ADDWF  x0B,W
2E5A:  MOVWF  FE9
2E5C:  MOVLW  00
2E5E:  ADDWFC x0C,W
2E60:  MOVWF  FEA
2E62:  MOVFF  FEF,14D
2E66:  MOVLW  0A
2E68:  MOVWF  x4E
2E6A:  MOVLB  0
2E6C:  CALL   07D0
2E70:  MOVLW  30
2E72:  ADDWF  01,W
2E74:  MOVLB  1
2E76:  MOVWF  x22
....................         date_c[7]   = my_time->tm_mday % 10 + '0'; 
2E78:  MOVLW  03
2E7A:  ADDWF  x0B,W
2E7C:  MOVWF  FE9
2E7E:  MOVLW  00
2E80:  ADDWFC x0C,W
2E82:  MOVWF  FEA
2E84:  MOVFF  FEF,14D
2E88:  MOVLW  0A
2E8A:  MOVWF  x4E
2E8C:  MOVLB  0
2E8E:  CALL   07D0
2E92:  MOVLW  30
2E94:  ADDWF  00,W
2E96:  MOVLB  1
2E98:  MOVWF  x23
....................         date_c[9]   = (my_time->tm_mon + 1)  / 10 + '0'; 
2E9A:  MOVLW  04
2E9C:  ADDWF  x0B,W
2E9E:  MOVWF  FE9
2EA0:  MOVLW  00
2EA2:  ADDWFC x0C,W
2EA4:  MOVWF  FEA
2EA6:  MOVLW  01
2EA8:  ADDWF  FEF,W
2EAA:  MOVWF  x42
2EAC:  MOVWF  x4D
2EAE:  MOVLW  0A
2EB0:  MOVWF  x4E
2EB2:  MOVLB  0
2EB4:  CALL   07D0
2EB8:  MOVLW  30
2EBA:  ADDWF  01,W
2EBC:  MOVLB  1
2EBE:  MOVWF  x25
....................         date_c[10]  = (my_time->tm_mon + 1)  % 10 + '0'; 
2EC0:  MOVLW  04
2EC2:  ADDWF  x0B,W
2EC4:  MOVWF  FE9
2EC6:  MOVLW  00
2EC8:  ADDWFC x0C,W
2ECA:  MOVWF  FEA
2ECC:  MOVLW  01
2ECE:  ADDWF  FEF,W
2ED0:  MOVWF  x42
2ED2:  MOVWF  x4D
2ED4:  MOVLW  0A
2ED6:  MOVWF  x4E
2ED8:  MOVLB  0
2EDA:  CALL   07D0
2EDE:  MOVLW  30
2EE0:  ADDWF  00,W
2EE2:  MOVLB  1
2EE4:  MOVWF  x26
....................         date_c[14]  = (my_time->tm_year / 10) % 10 + '0'; 
2EE6:  MOVLW  05
2EE8:  ADDWF  x0B,W
2EEA:  MOVWF  FE9
2EEC:  MOVLW  00
2EEE:  ADDWFC x0C,W
2EF0:  MOVWF  FEA
2EF2:  MOVFF  FEC,142
2EF6:  MOVF   FED,F
2EF8:  MOVFF  FEF,141
2EFC:  MOVFF  142,151
2F00:  MOVFF  141,150
2F04:  CLRF   x53
2F06:  MOVLW  0A
2F08:  MOVWF  x52
2F0A:  MOVLB  0
2F0C:  CALL   0702
2F10:  MOVFF  02,142
2F14:  MOVFF  01,141
2F18:  MOVFF  02,151
2F1C:  MOVFF  01,150
2F20:  MOVLB  1
2F22:  CLRF   x53
2F24:  MOVLW  0A
2F26:  MOVWF  x52
2F28:  MOVLB  0
2F2A:  CALL   0702
2F2E:  MOVLB  1
2F30:  MOVLW  30
2F32:  ADDWF  00,W
2F34:  MOVWF  x2A
....................         date_c[15]  = my_time->tm_year  % 10 + '0';         
2F36:  MOVLW  05
2F38:  ADDWF  x0B,W
2F3A:  MOVWF  FE9
2F3C:  MOVLW  00
2F3E:  ADDWFC x0C,W
2F40:  MOVWF  FEA
2F42:  MOVFF  FEC,142
2F46:  MOVF   FED,F
2F48:  MOVFF  FEF,141
2F4C:  MOVFF  142,151
2F50:  MOVFF  141,150
2F54:  CLRF   x53
2F56:  MOVLW  0A
2F58:  MOVWF  x52
2F5A:  MOVLB  0
2F5C:  CALL   0702
2F60:  MOVLB  1
2F62:  MOVLW  30
2F64:  ADDWF  00,W
2F66:  MOVWF  x2B
....................         datee_c[1]  = (my_time->tm_mon + 1)  / 10 + '0'; 
2F68:  MOVLW  04
2F6A:  ADDWF  x0B,W
2F6C:  MOVWF  FE9
2F6E:  MOVLW  00
2F70:  ADDWFC x0C,W
2F72:  MOVWF  FEA
2F74:  MOVLW  01
2F76:  ADDWF  FEF,W
2F78:  MOVWF  x42
2F7A:  MOVWF  x4D
2F7C:  MOVLW  0A
2F7E:  MOVWF  x4E
2F80:  MOVLB  0
2F82:  CALL   07D0
2F86:  MOVLW  30
2F88:  ADDWF  01,W
2F8A:  MOVLB  1
2F8C:  MOVWF  x30
....................         datee_c[2]  = (my_time->tm_mon + 1)  % 10 + '0'; 
2F8E:  MOVLW  04
2F90:  ADDWF  x0B,W
2F92:  MOVWF  FE9
2F94:  MOVLW  00
2F96:  ADDWFC x0C,W
2F98:  MOVWF  FEA
2F9A:  MOVLW  01
2F9C:  ADDWF  FEF,W
2F9E:  MOVWF  x42
2FA0:  MOVWF  x4D
2FA2:  MOVLW  0A
2FA4:  MOVWF  x4E
2FA6:  MOVLB  0
2FA8:  CALL   07D0
2FAC:  MOVLW  30
2FAE:  ADDWF  00,W
2FB0:  MOVLB  1
2FB2:  MOVWF  x31
....................         ano_c[1]    = (my_time->tm_year / 10) % 10 + '0'; 
2FB4:  MOVLW  05
2FB6:  ADDWF  x0B,W
2FB8:  MOVWF  FE9
2FBA:  MOVLW  00
2FBC:  ADDWFC x0C,W
2FBE:  MOVWF  FEA
2FC0:  MOVFF  FEC,142
2FC4:  MOVF   FED,F
2FC6:  MOVFF  FEF,141
2FCA:  MOVFF  142,151
2FCE:  MOVFF  141,150
2FD2:  CLRF   x53
2FD4:  MOVLW  0A
2FD6:  MOVWF  x52
2FD8:  MOVLB  0
2FDA:  CALL   0702
2FDE:  MOVFF  02,142
2FE2:  MOVFF  01,141
2FE6:  MOVFF  02,151
2FEA:  MOVFF  01,150
2FEE:  MOVLB  1
2FF0:  CLRF   x53
2FF2:  MOVLW  0A
2FF4:  MOVWF  x52
2FF6:  MOVLB  0
2FF8:  CALL   0702
2FFC:  MOVLB  1
2FFE:  MOVLW  30
3000:  ADDWF  00,W
3002:  MOVWF  x36
....................         ano_c[1]    = my_time->tm_year  % 10 + '0';         
3004:  MOVLW  05
3006:  ADDWF  x0B,W
3008:  MOVWF  FE9
300A:  MOVLW  00
300C:  ADDWFC x0C,W
300E:  MOVWF  FEA
3010:  MOVFF  FEC,142
3014:  MOVF   FED,F
3016:  MOVFF  FEF,141
301A:  MOVFF  142,151
301E:  MOVFF  141,150
3022:  CLRF   x53
3024:  MOVLW  0A
3026:  MOVWF  x52
3028:  MOVLB  0
302A:  CALL   0702
302E:  MOVLB  1
3030:  MOVLW  30
3032:  ADDWF  00,W
3034:  MOVWF  x36
....................         //presenta los datos de la fecha  
....................         print_wday(my_time->tm_wday);          //presenta la semana  
3036:  MOVLW  07
3038:  ADDWF  x0B,W
303A:  MOVWF  FE9
303C:  MOVLW  00
303E:  ADDWFC x0C,W
3040:  MOVWF  FEA
3042:  MOVFF  FEF,141
3046:  MOVFF  141,142
304A:  MOVLB  0
304C:  GOTO   1230
....................         lcd_gotoxy(23, 1);                     //cambio de posicion en la pantalla lcd  
3050:  MOVLW  17
3052:  MOVLB  1
3054:  MOVWF  x4F
3056:  MOVLW  01
3058:  MOVWF  x50
305A:  MOVLB  0
305C:  CALL   025C
....................         printf(lcd_putc, time_c);              //presenta la fecha en formato (HH:MM:SS) 
3060:  MOVLW  01
3062:  MOVWF  FEA
3064:  MOVLW  0D
3066:  MOVWF  FE9
3068:  CALL   12C4
....................         lcd_gotoxy(23, 2);                     //cambio de posicion en la pantalla lcd  
306C:  MOVLW  17
306E:  MOVLB  1
3070:  MOVWF  x4F
3072:  MOVLW  02
3074:  MOVWF  x50
3076:  MOVLB  0
3078:  CALL   025C
....................         printf(lcd_putc, date_c);              //presenta la fecha en formato(DD-MM-YYYY) 
307C:  MOVLW  01
307E:  MOVWF  FEA
3080:  MOVLW  1C
3082:  MOVWF  FE9
3084:  CALL   12C4
....................         mes = atof(datee_c);                     
3088:  MOVLW  01
308A:  MOVLB  1
308C:  MOVWF  x42
308E:  MOVLW  2F
3090:  MOVWF  x41
3092:  CLRF   x44
3094:  CLRF   x43
3096:  MOVLB  0
3098:  CALL   17EC
309C:  MOVFF  03,F8
30A0:  MOVFF  02,F7
30A4:  MOVFF  01,F6
30A8:  MOVFF  00,F5
....................         year = 2021; 
30AC:  CLRF   xFC
30AE:  MOVLW  A0
30B0:  MOVWF  xFB
30B2:  MOVLW  7C
30B4:  MOVWF  xFA
30B6:  MOVLW  89
30B8:  MOVWF  xF9
....................         //Ecuacion para obtener el numero del dia en el ao (0 a 356) 
....................         if (mes==1) {da1 = dia;}   
30BA:  MOVFF  F8,188
30BE:  MOVFF  F7,187
30C2:  MOVFF  F6,186
30C6:  MOVFF  F5,185
30CA:  MOVLB  1
30CC:  CLRF   x8C
30CE:  CLRF   x8B
30D0:  CLRF   x8A
30D2:  MOVLW  7F
30D4:  MOVWF  x89
30D6:  MOVLB  0
30D8:  CALL   1A3A
30DC:  BNZ   30EE
30DE:  MOVFF  F4,C0
30E2:  MOVFF  F3,BF
30E6:  MOVFF  F2,BE
30EA:  MOVFF  F1,BD
....................         if (mes==2) {da1 = 31 + dia;} 
30EE:  MOVFF  F8,188
30F2:  MOVFF  F7,187
30F6:  MOVFF  F6,186
30FA:  MOVFF  F5,185
30FE:  MOVLB  1
3100:  CLRF   x8C
3102:  CLRF   x8B
3104:  CLRF   x8A
3106:  MOVLW  80
3108:  MOVWF  x89
310A:  MOVLB  0
310C:  CALL   1A3A
3110:  BNZ   3148
3112:  BCF    FD8.1
3114:  MOVLB  1
3116:  CLRF   x8C
3118:  CLRF   x8B
311A:  MOVLW  78
311C:  MOVWF  x8A
311E:  MOVLW  83
3120:  MOVWF  x89
3122:  MOVFF  F4,190
3126:  MOVFF  F3,18F
312A:  MOVFF  F2,18E
312E:  MOVFF  F1,18D
3132:  MOVLB  0
3134:  CALL   1574
3138:  MOVFF  03,C0
313C:  MOVFF  02,BF
3140:  MOVFF  01,BE
3144:  MOVFF  00,BD
....................         if (mes>=3) { 
3148:  MOVLB  1
314A:  CLRF   x88
314C:  CLRF   x87
314E:  MOVLW  40
3150:  MOVWF  x86
3152:  MOVLW  80
3154:  MOVWF  x85
3156:  MOVFF  F8,18C
315A:  MOVFF  F7,18B
315E:  MOVFF  F6,18A
3162:  MOVFF  F5,189
3166:  MOVLB  0
3168:  CALL   1A3A
316C:  BC    3172
316E:  BTFSS  FD8.2
3170:  BRA    348A
....................           N1 = (275*mes/9);  
3172:  MOVLB  1
3174:  CLRF   x8C
3176:  MOVLW  80
3178:  MOVWF  x8B
317A:  MOVLW  09
317C:  MOVWF  x8A
317E:  MOVLW  87
3180:  MOVWF  x89
3182:  MOVFF  F8,190
3186:  MOVFF  F7,18F
318A:  MOVFF  F6,18E
318E:  MOVFF  F5,18D
3192:  MOVLB  0
3194:  CALL   12EA
3198:  MOVFF  03,144
319C:  MOVFF  02,143
31A0:  MOVFF  01,142
31A4:  MOVFF  00,141
31A8:  MOVFF  03,178
31AC:  MOVFF  02,177
31B0:  MOVFF  01,176
31B4:  MOVFF  00,175
31B8:  MOVLB  1
31BA:  CLRF   x7C
31BC:  CLRF   x7B
31BE:  MOVLW  10
31C0:  MOVWF  x7A
31C2:  MOVLW  82
31C4:  MOVWF  x79
31C6:  MOVLB  0
31C8:  CALL   1416
31CC:  MOVFF  03,C4
31D0:  MOVFF  02,C3
31D4:  MOVFF  01,C2
31D8:  MOVFF  00,C1
....................           N2 = (mes+9)/12;  
31DC:  BCF    FD8.1
31DE:  MOVFF  F8,18C
31E2:  MOVFF  F7,18B
31E6:  MOVFF  F6,18A
31EA:  MOVFF  F5,189
31EE:  MOVLB  1
31F0:  CLRF   x90
31F2:  CLRF   x8F
31F4:  MOVLW  10
31F6:  MOVWF  x8E
31F8:  MOVLW  82
31FA:  MOVWF  x8D
31FC:  MOVLB  0
31FE:  CALL   1574
3202:  MOVFF  03,144
3206:  MOVFF  02,143
320A:  MOVFF  01,142
320E:  MOVFF  00,141
3212:  MOVFF  03,178
3216:  MOVFF  02,177
321A:  MOVFF  01,176
321E:  MOVFF  00,175
3222:  MOVLB  1
3224:  CLRF   x7C
3226:  CLRF   x7B
3228:  MOVLW  40
322A:  MOVWF  x7A
322C:  MOVLW  82
322E:  MOVWF  x79
3230:  MOVLB  0
3232:  CALL   1416
3236:  MOVFF  03,C8
323A:  MOVFF  02,C7
323E:  MOVFF  01,C6
3242:  MOVFF  00,C5
....................           N3 = (1 + floor((year - 4 * floor(year / 4) + 2) / 3));  
3246:  MOVFF  FC,178
324A:  MOVFF  FB,177
324E:  MOVFF  FA,176
3252:  MOVFF  F9,175
3256:  MOVLB  1
3258:  CLRF   x7C
325A:  CLRF   x7B
325C:  CLRF   x7A
325E:  MOVLW  81
3260:  MOVWF  x79
3262:  MOVLB  0
3264:  CALL   1416
3268:  MOVFF  03,144
326C:  MOVFF  02,143
3270:  MOVFF  01,142
3274:  MOVFF  00,141
3278:  MOVFF  03,14C
327C:  MOVFF  02,14B
3280:  MOVFF  01,14A
3284:  MOVFF  00,149
3288:  CALL   1E50
328C:  MOVLB  1
328E:  CLRF   x8C
3290:  CLRF   x8B
3292:  CLRF   x8A
3294:  MOVLW  81
3296:  MOVWF  x89
3298:  MOVFF  03,190
329C:  MOVFF  02,18F
32A0:  MOVFF  01,18E
32A4:  MOVFF  00,18D
32A8:  MOVLB  0
32AA:  CALL   12EA
32AE:  MOVFF  FEA,142
32B2:  MOVFF  FE9,141
32B6:  BSF    FD8.1
32B8:  MOVFF  FC,18C
32BC:  MOVFF  FB,18B
32C0:  MOVFF  FA,18A
32C4:  MOVFF  F9,189
32C8:  MOVFF  03,190
32CC:  MOVFF  02,18F
32D0:  MOVFF  01,18E
32D4:  MOVFF  00,18D
32D8:  CALL   1574
32DC:  MOVFF  142,FEA
32E0:  MOVFF  141,FE9
32E4:  MOVFF  03,146
32E8:  MOVFF  02,145
32EC:  MOVFF  01,144
32F0:  MOVFF  00,143
32F4:  MOVFF  FEA,148
32F8:  MOVFF  FE9,147
32FC:  BCF    FD8.1
32FE:  MOVFF  03,18C
3302:  MOVFF  02,18B
3306:  MOVFF  01,18A
330A:  MOVFF  00,189
330E:  MOVLB  1
3310:  CLRF   x90
3312:  CLRF   x8F
3314:  CLRF   x8E
3316:  MOVLW  80
3318:  MOVWF  x8D
331A:  MOVLB  0
331C:  CALL   1574
3320:  MOVFF  148,FEA
3324:  MOVFF  147,FE9
3328:  MOVFF  03,146
332C:  MOVFF  02,145
3330:  MOVFF  01,144
3334:  MOVFF  00,143
3338:  MOVFF  03,178
333C:  MOVFF  02,177
3340:  MOVFF  01,176
3344:  MOVFF  00,175
3348:  MOVLB  1
334A:  CLRF   x7C
334C:  CLRF   x7B
334E:  MOVLW  40
3350:  MOVWF  x7A
3352:  MOVLW  80
3354:  MOVWF  x79
3356:  MOVLB  0
3358:  CALL   1416
335C:  MOVFF  03,146
3360:  MOVFF  02,145
3364:  MOVFF  01,144
3368:  MOVFF  00,143
336C:  MOVFF  03,14C
3370:  MOVFF  02,14B
3374:  MOVFF  01,14A
3378:  MOVFF  00,149
337C:  CALL   1E50
3380:  MOVFF  FEA,144
3384:  MOVFF  FE9,143
3388:  BCF    FD8.1
338A:  MOVLB  1
338C:  CLRF   x8C
338E:  CLRF   x8B
3390:  CLRF   x8A
3392:  MOVLW  7F
3394:  MOVWF  x89
3396:  MOVFF  03,190
339A:  MOVFF  02,18F
339E:  MOVFF  01,18E
33A2:  MOVFF  00,18D
33A6:  MOVLB  0
33A8:  CALL   1574
33AC:  MOVFF  144,FEA
33B0:  MOVFF  143,FE9
33B4:  MOVFF  03,CC
33B8:  MOVFF  02,CB
33BC:  MOVFF  01,CA
33C0:  MOVFF  00,C9
....................           da1 = N1 -(N2*N3) + dia - 30; 
33C4:  MOVFF  C8,18C
33C8:  MOVFF  C7,18B
33CC:  MOVFF  C6,18A
33D0:  MOVFF  C5,189
33D4:  MOVFF  CC,190
33D8:  MOVFF  CB,18F
33DC:  MOVFF  CA,18E
33E0:  MOVFF  C9,18D
33E4:  CALL   12EA
33E8:  BSF    FD8.1
33EA:  MOVFF  C4,18C
33EE:  MOVFF  C3,18B
33F2:  MOVFF  C2,18A
33F6:  MOVFF  C1,189
33FA:  MOVFF  03,190
33FE:  MOVFF  02,18F
3402:  MOVFF  01,18E
3406:  MOVFF  00,18D
340A:  CALL   1574
340E:  MOVFF  03,144
3412:  MOVFF  02,143
3416:  MOVFF  01,142
341A:  MOVFF  00,141
341E:  BCF    FD8.1
3420:  MOVFF  03,18C
3424:  MOVFF  02,18B
3428:  MOVFF  01,18A
342C:  MOVFF  00,189
3430:  MOVFF  F4,190
3434:  MOVFF  F3,18F
3438:  MOVFF  F2,18E
343C:  MOVFF  F1,18D
3440:  CALL   1574
3444:  MOVFF  03,144
3448:  MOVFF  02,143
344C:  MOVFF  01,142
3450:  MOVFF  00,141
3454:  BSF    FD8.1
3456:  MOVFF  03,18C
345A:  MOVFF  02,18B
345E:  MOVFF  01,18A
3462:  MOVFF  00,189
3466:  MOVLB  1
3468:  CLRF   x90
346A:  CLRF   x8F
346C:  MOVLW  70
346E:  MOVWF  x8E
3470:  MOVLW  83
3472:  MOVWF  x8D
3474:  MOVLB  0
3476:  CALL   1574
347A:  MOVFF  03,C0
347E:  MOVFF  02,BF
3482:  MOVFF  01,BE
3486:  MOVFF  00,BD
....................         }  
....................         //Ecuacion para obtener el numero del dia 
....................         adia1 = ((2*pi)/365)*(da1-1); //Ecuacion de dia 
348A:  BSF    FD8.1
348C:  MOVFF  C0,18C
3490:  MOVFF  BF,18B
3494:  MOVFF  BE,18A
3498:  MOVFF  BD,189
349C:  MOVLB  1
349E:  CLRF   x90
34A0:  CLRF   x8F
34A2:  CLRF   x8E
34A4:  MOVLW  7F
34A6:  MOVWF  x8D
34A8:  MOVLB  0
34AA:  CALL   1574
34AE:  MOVLW  CF
34B0:  MOVLB  1
34B2:  MOVWF  x8C
34B4:  MOVLW  04
34B6:  MOVWF  x8B
34B8:  MOVLW  0D
34BA:  MOVWF  x8A
34BC:  MOVLW  79
34BE:  MOVWF  x89
34C0:  MOVFF  03,190
34C4:  MOVFF  02,18F
34C8:  MOVFF  01,18E
34CC:  MOVFF  00,18D
34D0:  MOVLB  0
34D2:  CALL   12EA
34D6:  MOVFF  03,D0
34DA:  MOVFF  02,CF
34DE:  MOVFF  01,CE
34E2:  MOVFF  00,CD
....................         eti =( 
....................           ((0.000073) + (0.001868*(cos(adia1)))    
....................           - (0.0320777*(sin(adia1))) - (0.014615 * (cos(2*adia1)))  
....................           - (0.04089*(sin(2*adia1)))) * (229.18) 
....................         );  
34E6:  MOVFF  D0,15E
34EA:  MOVFF  CF,15D
34EE:  MOVFF  CE,15C
34F2:  MOVFF  CD,15B
34F6:  CALL   1E6A
34FA:  MOVLW  AE
34FC:  MOVLB  1
34FE:  MOVWF  x8C
3500:  MOVLW  D7
3502:  MOVWF  x8B
3504:  MOVLW  74
3506:  MOVWF  x8A
3508:  MOVLW  75
350A:  MOVWF  x89
350C:  MOVFF  03,190
3510:  MOVFF  02,18F
3514:  MOVFF  01,18E
3518:  MOVFF  00,18D
351C:  MOVLB  0
351E:  CALL   12EA
3522:  MOVFF  FEA,142
3526:  MOVFF  FE9,141
352A:  BCF    FD8.1
352C:  MOVLW  94
352E:  MOVLB  1
3530:  MOVWF  x8C
3532:  MOVLW  17
3534:  MOVWF  x8B
3536:  MOVLW  19
3538:  MOVWF  x8A
353A:  MOVLW  71
353C:  MOVWF  x89
353E:  MOVFF  03,190
3542:  MOVFF  02,18F
3546:  MOVFF  01,18E
354A:  MOVFF  00,18D
354E:  MOVLB  0
3550:  CALL   1574
3554:  MOVFF  142,FEA
3558:  MOVFF  141,FE9
355C:  MOVFF  03,146
3560:  MOVFF  02,145
3564:  MOVFF  01,144
3568:  MOVFF  00,143
356C:  MOVFF  D0,156
3570:  MOVFF  CF,155
3574:  MOVFF  CE,154
3578:  MOVFF  CD,153
357C:  CALL   2206
3580:  MOVLW  E8
3582:  MOVLB  1
3584:  MOVWF  x8C
3586:  MOVLW  63
3588:  MOVWF  x8B
358A:  MOVLW  03
358C:  MOVWF  x8A
358E:  MOVLW  7A
3590:  MOVWF  x89
3592:  MOVFF  03,190
3596:  MOVFF  02,18F
359A:  MOVFF  01,18E
359E:  MOVFF  00,18D
35A2:  MOVLB  0
35A4:  CALL   12EA
35A8:  MOVFF  FEA,148
35AC:  MOVFF  FE9,147
35B0:  BSF    FD8.1
35B2:  MOVFF  146,18C
35B6:  MOVFF  145,18B
35BA:  MOVFF  144,18A
35BE:  MOVFF  143,189
35C2:  MOVFF  03,190
35C6:  MOVFF  02,18F
35CA:  MOVFF  01,18E
35CE:  MOVFF  00,18D
35D2:  CALL   1574
35D6:  MOVFF  148,FEA
35DA:  MOVFF  147,FE9
35DE:  MOVFF  03,146
35E2:  MOVFF  02,145
35E6:  MOVFF  01,144
35EA:  MOVFF  00,143
35EE:  MOVLB  1
35F0:  CLRF   x8C
35F2:  CLRF   x8B
35F4:  CLRF   x8A
35F6:  MOVLW  80
35F8:  MOVWF  x89
35FA:  MOVFF  D0,190
35FE:  MOVFF  CF,18F
3602:  MOVFF  CE,18E
3606:  MOVFF  CD,18D
360A:  MOVLB  0
360C:  CALL   12EA
3610:  MOVFF  03,14C
3614:  MOVFF  02,14B
3618:  MOVFF  01,14A
361C:  MOVFF  00,149
3620:  MOVFF  03,15E
3624:  MOVFF  02,15D
3628:  MOVFF  01,15C
362C:  MOVFF  00,15B
3630:  CALL   1E6A
3634:  MOVLW  C1
3636:  MOVLB  1
3638:  MOVWF  x8C
363A:  MOVLW  73
363C:  MOVWF  x8B
363E:  MOVLW  6F
3640:  MOVWF  x8A
3642:  MOVLW  78
3644:  MOVWF  x89
3646:  MOVFF  03,190
364A:  MOVFF  02,18F
364E:  MOVFF  01,18E
3652:  MOVFF  00,18D
3656:  MOVLB  0
3658:  CALL   12EA
365C:  MOVFF  FEA,14A
3660:  MOVFF  FE9,149
3664:  BSF    FD8.1
3666:  MOVFF  146,18C
366A:  MOVFF  145,18B
366E:  MOVFF  144,18A
3672:  MOVFF  143,189
3676:  MOVFF  03,190
367A:  MOVFF  02,18F
367E:  MOVFF  01,18E
3682:  MOVFF  00,18D
3686:  CALL   1574
368A:  MOVFF  14A,FEA
368E:  MOVFF  149,FE9
3692:  MOVFF  03,146
3696:  MOVFF  02,145
369A:  MOVFF  01,144
369E:  MOVFF  00,143
36A2:  MOVLB  1
36A4:  CLRF   x8C
36A6:  CLRF   x8B
36A8:  CLRF   x8A
36AA:  MOVLW  80
36AC:  MOVWF  x89
36AE:  MOVFF  D0,190
36B2:  MOVFF  CF,18F
36B6:  MOVFF  CE,18E
36BA:  MOVFF  CD,18D
36BE:  MOVLB  0
36C0:  CALL   12EA
36C4:  MOVFF  03,14E
36C8:  MOVFF  02,14D
36CC:  MOVFF  01,14C
36D0:  MOVFF  00,14B
36D4:  MOVFF  03,156
36D8:  MOVFF  02,155
36DC:  MOVFF  01,154
36E0:  MOVFF  00,153
36E4:  CALL   2206
36E8:  MOVLW  46
36EA:  MOVLB  1
36EC:  MOVWF  x8C
36EE:  MOVLW  7C
36F0:  MOVWF  x8B
36F2:  MOVLW  27
36F4:  MOVWF  x8A
36F6:  MOVLW  7A
36F8:  MOVWF  x89
36FA:  MOVFF  03,190
36FE:  MOVFF  02,18F
3702:  MOVFF  01,18E
3706:  MOVFF  00,18D
370A:  MOVLB  0
370C:  CALL   12EA
3710:  MOVFF  FEA,14C
3714:  MOVFF  FE9,14B
3718:  BSF    FD8.1
371A:  MOVFF  146,18C
371E:  MOVFF  145,18B
3722:  MOVFF  144,18A
3726:  MOVFF  143,189
372A:  MOVFF  03,190
372E:  MOVFF  02,18F
3732:  MOVFF  01,18E
3736:  MOVFF  00,18D
373A:  CALL   1574
373E:  MOVFF  14C,FEA
3742:  MOVFF  14B,FE9
3746:  MOVFF  03,146
374A:  MOVFF  02,145
374E:  MOVFF  01,144
3752:  MOVFF  00,143
3756:  MOVFF  03,18C
375A:  MOVFF  02,18B
375E:  MOVFF  01,18A
3762:  MOVFF  00,189
3766:  MOVLW  14
3768:  MOVLB  1
376A:  MOVWF  x90
376C:  MOVLW  2E
376E:  MOVWF  x8F
3770:  MOVLW  65
3772:  MOVWF  x8E
3774:  MOVLW  86
3776:  MOVWF  x8D
3778:  MOVLB  0
377A:  CALL   12EA
377E:  MOVFF  03,7C
3782:  MOVFF  02,7B
3786:  MOVFF  01,7A
378A:  MOVFF  00,79
....................         //Correcion del tiempo, resultado en minutos 
....................         to = eti + (4*lon) - (60*-5); 
378E:  MOVLB  1
3790:  CLRF   x8C
3792:  CLRF   x8B
3794:  CLRF   x8A
3796:  MOVLW  81
3798:  MOVWF  x89
379A:  MOVFF  78,190
379E:  MOVFF  77,18F
37A2:  MOVFF  76,18E
37A6:  MOVFF  75,18D
37AA:  MOVLB  0
37AC:  CALL   12EA
37B0:  BCF    FD8.1
37B2:  MOVFF  7C,18C
37B6:  MOVFF  7B,18B
37BA:  MOVFF  7A,18A
37BE:  MOVFF  79,189
37C2:  MOVFF  03,190
37C6:  MOVFF  02,18F
37CA:  MOVFF  01,18E
37CE:  MOVFF  00,18D
37D2:  CALL   1574
37D6:  MOVFF  03,144
37DA:  MOVFF  02,143
37DE:  MOVFF  01,142
37E2:  MOVFF  00,141
37E6:  BSF    FD8.1
37E8:  MOVFF  03,18C
37EC:  MOVFF  02,18B
37F0:  MOVFF  01,18A
37F4:  MOVFF  00,189
37F8:  MOVLB  1
37FA:  CLRF   x90
37FC:  CLRF   x8F
37FE:  MOVLW  96
3800:  MOVWF  x8E
3802:  MOVLW  87
3804:  MOVWF  x8D
3806:  MOVLB  0
3808:  CALL   1574
380C:  MOVFF  03,84
3810:  MOVFF  02,83
3814:  MOVFF  01,82
3818:  MOVFF  00,81
....................         //Declinacion solar 
....................         dec1 =( 
....................           (0.006918-(0.39912*cos(adia1)) + (0.070257*sin(adia1))  
....................           - (0.006758*cos(2*adia1)) + (0.0009907*sin(2*adia1))  
....................           - (0.002697*cos(3*adia1))+(0.00148*sin(3*adia1))) 
....................         ); 
381C:  MOVFF  D0,15E
3820:  MOVFF  CF,15D
3824:  MOVFF  CE,15C
3828:  MOVFF  CD,15B
382C:  CALL   1E6A
3830:  MOVLW  75
3832:  MOVLB  1
3834:  MOVWF  x8C
3836:  MOVLW  59
3838:  MOVWF  x8B
383A:  MOVLW  4C
383C:  MOVWF  x8A
383E:  MOVLW  7D
3840:  MOVWF  x89
3842:  MOVFF  03,190
3846:  MOVFF  02,18F
384A:  MOVFF  01,18E
384E:  MOVFF  00,18D
3852:  MOVLB  0
3854:  CALL   12EA
3858:  MOVFF  FEA,142
385C:  MOVFF  FE9,141
3860:  BSF    FD8.1
3862:  MOVLW  64
3864:  MOVLB  1
3866:  MOVWF  x8C
3868:  MOVLW  B0
386A:  MOVWF  x8B
386C:  MOVLW  62
386E:  MOVWF  x8A
3870:  MOVLW  77
3872:  MOVWF  x89
3874:  MOVFF  03,190
3878:  MOVFF  02,18F
387C:  MOVFF  01,18E
3880:  MOVFF  00,18D
3884:  MOVLB  0
3886:  CALL   1574
388A:  MOVFF  142,FEA
388E:  MOVFF  141,FE9
3892:  MOVFF  03,146
3896:  MOVFF  02,145
389A:  MOVFF  01,144
389E:  MOVFF  00,143
38A2:  MOVFF  D0,156
38A6:  MOVFF  CF,155
38AA:  MOVFF  CE,154
38AE:  MOVFF  CD,153
38B2:  CALL   2206
38B6:  MOVLW  E7
38B8:  MOVLB  1
38BA:  MOVWF  x8C
38BC:  MOVLW  E2
38BE:  MOVWF  x8B
38C0:  MOVLW  0F
38C2:  MOVWF  x8A
38C4:  MOVLW  7B
38C6:  MOVWF  x89
38C8:  MOVFF  03,190
38CC:  MOVFF  02,18F
38D0:  MOVFF  01,18E
38D4:  MOVFF  00,18D
38D8:  MOVLB  0
38DA:  CALL   12EA
38DE:  MOVFF  FEA,148
38E2:  MOVFF  FE9,147
38E6:  BCF    FD8.1
38E8:  MOVFF  146,18C
38EC:  MOVFF  145,18B
38F0:  MOVFF  144,18A
38F4:  MOVFF  143,189
38F8:  MOVFF  03,190
38FC:  MOVFF  02,18F
3900:  MOVFF  01,18E
3904:  MOVFF  00,18D
3908:  CALL   1574
390C:  MOVFF  148,FEA
3910:  MOVFF  147,FE9
3914:  MOVFF  03,146
3918:  MOVFF  02,145
391C:  MOVFF  01,144
3920:  MOVFF  00,143
3924:  MOVLB  1
3926:  CLRF   x8C
3928:  CLRF   x8B
392A:  CLRF   x8A
392C:  MOVLW  80
392E:  MOVWF  x89
3930:  MOVFF  D0,190
3934:  MOVFF  CF,18F
3938:  MOVFF  CE,18E
393C:  MOVFF  CD,18D
3940:  MOVLB  0
3942:  CALL   12EA
3946:  MOVFF  03,14C
394A:  MOVFF  02,14B
394E:  MOVFF  01,14A
3952:  MOVFF  00,149
3956:  MOVFF  03,15E
395A:  MOVFF  02,15D
395E:  MOVFF  01,15C
3962:  MOVFF  00,15B
3966:  CALL   1E6A
396A:  MOVLW  36
396C:  MOVLB  1
396E:  MOVWF  x8C
3970:  MOVLW  72
3972:  MOVWF  x8B
3974:  MOVLW  5D
3976:  MOVWF  x8A
3978:  MOVLW  77
397A:  MOVWF  x89
397C:  MOVFF  03,190
3980:  MOVFF  02,18F
3984:  MOVFF  01,18E
3988:  MOVFF  00,18D
398C:  MOVLB  0
398E:  CALL   12EA
3992:  MOVFF  FEA,14A
3996:  MOVFF  FE9,149
399A:  BSF    FD8.1
399C:  MOVFF  146,18C
39A0:  MOVFF  145,18B
39A4:  MOVFF  144,18A
39A8:  MOVFF  143,189
39AC:  MOVFF  03,190
39B0:  MOVFF  02,18F
39B4:  MOVFF  01,18E
39B8:  MOVFF  00,18D
39BC:  CALL   1574
39C0:  MOVFF  14A,FEA
39C4:  MOVFF  149,FE9
39C8:  MOVFF  03,146
39CC:  MOVFF  02,145
39D0:  MOVFF  01,144
39D4:  MOVFF  00,143
39D8:  MOVLB  1
39DA:  CLRF   x8C
39DC:  CLRF   x8B
39DE:  CLRF   x8A
39E0:  MOVLW  80
39E2:  MOVWF  x89
39E4:  MOVFF  D0,190
39E8:  MOVFF  CF,18F
39EC:  MOVFF  CE,18E
39F0:  MOVFF  CD,18D
39F4:  MOVLB  0
39F6:  CALL   12EA
39FA:  MOVFF  03,14E
39FE:  MOVFF  02,14D
3A02:  MOVFF  01,14C
3A06:  MOVFF  00,14B
3A0A:  MOVFF  03,156
3A0E:  MOVFF  02,155
3A12:  MOVFF  01,154
3A16:  MOVFF  00,153
3A1A:  CALL   2206
3A1E:  MOVLW  60
3A20:  MOVLB  1
3A22:  MOVWF  x8C
3A24:  MOVLW  DA
3A26:  MOVWF  x8B
3A28:  MOVLW  01
3A2A:  MOVWF  x8A
3A2C:  MOVLW  75
3A2E:  MOVWF  x89
3A30:  MOVFF  03,190
3A34:  MOVFF  02,18F
3A38:  MOVFF  01,18E
3A3C:  MOVFF  00,18D
3A40:  MOVLB  0
3A42:  CALL   12EA
3A46:  MOVFF  FEA,14C
3A4A:  MOVFF  FE9,14B
3A4E:  BCF    FD8.1
3A50:  MOVFF  146,18C
3A54:  MOVFF  145,18B
3A58:  MOVFF  144,18A
3A5C:  MOVFF  143,189
3A60:  MOVFF  03,190
3A64:  MOVFF  02,18F
3A68:  MOVFF  01,18E
3A6C:  MOVFF  00,18D
3A70:  CALL   1574
3A74:  MOVFF  14C,FEA
3A78:  MOVFF  14B,FE9
3A7C:  MOVFF  03,146
3A80:  MOVFF  02,145
3A84:  MOVFF  01,144
3A88:  MOVFF  00,143
3A8C:  MOVLB  1
3A8E:  CLRF   x8C
3A90:  CLRF   x8B
3A92:  MOVLW  40
3A94:  MOVWF  x8A
3A96:  MOVLW  80
3A98:  MOVWF  x89
3A9A:  MOVFF  D0,190
3A9E:  MOVFF  CF,18F
3AA2:  MOVFF  CE,18E
3AA6:  MOVFF  CD,18D
3AAA:  MOVLB  0
3AAC:  CALL   12EA
3AB0:  MOVFF  03,150
3AB4:  MOVFF  02,14F
3AB8:  MOVFF  01,14E
3ABC:  MOVFF  00,14D
3AC0:  MOVFF  03,15E
3AC4:  MOVFF  02,15D
3AC8:  MOVFF  01,15C
3ACC:  MOVFF  00,15B
3AD0:  CALL   1E6A
3AD4:  MOVLW  27
3AD6:  MOVLB  1
3AD8:  MOVWF  x8C
3ADA:  MOVLW  C0
3ADC:  MOVWF  x8B
3ADE:  MOVLW  30
3AE0:  MOVWF  x8A
3AE2:  MOVLW  76
3AE4:  MOVWF  x89
3AE6:  MOVFF  03,190
3AEA:  MOVFF  02,18F
3AEE:  MOVFF  01,18E
3AF2:  MOVFF  00,18D
3AF6:  MOVLB  0
3AF8:  CALL   12EA
3AFC:  MOVFF  FEA,14E
3B00:  MOVFF  FE9,14D
3B04:  BSF    FD8.1
3B06:  MOVFF  146,18C
3B0A:  MOVFF  145,18B
3B0E:  MOVFF  144,18A
3B12:  MOVFF  143,189
3B16:  MOVFF  03,190
3B1A:  MOVFF  02,18F
3B1E:  MOVFF  01,18E
3B22:  MOVFF  00,18D
3B26:  CALL   1574
3B2A:  MOVFF  14E,FEA
3B2E:  MOVFF  14D,FE9
3B32:  MOVFF  03,146
3B36:  MOVFF  02,145
3B3A:  MOVFF  01,144
3B3E:  MOVFF  00,143
3B42:  MOVLB  1
3B44:  CLRF   x8C
3B46:  CLRF   x8B
3B48:  MOVLW  40
3B4A:  MOVWF  x8A
3B4C:  MOVLW  80
3B4E:  MOVWF  x89
3B50:  MOVFF  D0,190
3B54:  MOVFF  CF,18F
3B58:  MOVFF  CE,18E
3B5C:  MOVFF  CD,18D
3B60:  MOVLB  0
3B62:  CALL   12EA
3B66:  MOVFF  03,152
3B6A:  MOVFF  02,151
3B6E:  MOVFF  01,150
3B72:  MOVFF  00,14F
3B76:  MOVFF  03,156
3B7A:  MOVFF  02,155
3B7E:  MOVFF  01,154
3B82:  MOVFF  00,153
3B86:  CALL   2206
3B8A:  MOVLW  8F
3B8C:  MOVLB  1
3B8E:  MOVWF  x8C
3B90:  MOVLW  FC
3B92:  MOVWF  x8B
3B94:  MOVLW  41
3B96:  MOVWF  x8A
3B98:  MOVLW  75
3B9A:  MOVWF  x89
3B9C:  MOVFF  03,190
3BA0:  MOVFF  02,18F
3BA4:  MOVFF  01,18E
3BA8:  MOVFF  00,18D
3BAC:  MOVLB  0
3BAE:  CALL   12EA
3BB2:  MOVFF  FEA,150
3BB6:  MOVFF  FE9,14F
3BBA:  BCF    FD8.1
3BBC:  MOVFF  146,18C
3BC0:  MOVFF  145,18B
3BC4:  MOVFF  144,18A
3BC8:  MOVFF  143,189
3BCC:  MOVFF  03,190
3BD0:  MOVFF  02,18F
3BD4:  MOVFF  01,18E
3BD8:  MOVFF  00,18D
3BDC:  CALL   1574
3BE0:  MOVFF  150,FEA
3BE4:  MOVFF  14F,FE9
3BE8:  MOVFF  03,80
3BEC:  MOVFF  02,7F
3BF0:  MOVFF  01,7E
3BF4:  MOVFF  00,7D
....................         //Angulo horario a la salida del sol 
....................         ws = (acos(-tan(lat)*tan(dec1))); 
3BF8:  MOVFF  74,148
3BFC:  MOVFF  73,147
3C00:  MOVFF  72,146
3C04:  MOVFF  71,145
3C08:  CALL   2254
3C0C:  MOVFF  00,141
3C10:  MOVF   01,W
3C12:  XORLW  80
3C14:  MOVLB  1
3C16:  MOVWF  x42
3C18:  MOVFF  02,143
3C1C:  MOVFF  03,144
3C20:  MOVFF  80,148
3C24:  MOVFF  7F,147
3C28:  MOVFF  7E,146
3C2C:  MOVFF  7D,145
3C30:  MOVLB  0
3C32:  CALL   2254
3C36:  MOVFF  144,18C
3C3A:  MOVFF  143,18B
3C3E:  MOVFF  142,18A
3C42:  MOVFF  141,189
3C46:  MOVFF  03,190
3C4A:  MOVFF  02,18F
3C4E:  MOVFF  01,18E
3C52:  MOVFF  00,18D
3C56:  CALL   12EA
3C5A:  MOVFF  03,144
3C5E:  MOVFF  02,143
3C62:  MOVFF  01,142
3C66:  MOVFF  00,141
3C6A:  MOVFF  03,148
3C6E:  MOVFF  02,147
3C72:  MOVFF  01,146
3C76:  MOVFF  00,145
3C7A:  CALL   2822
3C7E:  MOVFF  03,88
3C82:  MOVFF  02,87
3C86:  MOVFF  01,86
3C8A:  MOVFF  00,85
....................         tc1 = 4*(lon+(15*5))+eti; 
3C8E:  BCF    FD8.1
3C90:  MOVFF  78,18C
3C94:  MOVFF  77,18B
3C98:  MOVFF  76,18A
3C9C:  MOVFF  75,189
3CA0:  MOVLB  1
3CA2:  CLRF   x90
3CA4:  CLRF   x8F
3CA6:  MOVLW  16
3CA8:  MOVWF  x8E
3CAA:  MOVLW  85
3CAC:  MOVWF  x8D
3CAE:  MOVLB  0
3CB0:  CALL   1574
3CB4:  MOVLB  1
3CB6:  CLRF   x8C
3CB8:  CLRF   x8B
3CBA:  CLRF   x8A
3CBC:  MOVLW  81
3CBE:  MOVWF  x89
3CC0:  MOVFF  03,190
3CC4:  MOVFF  02,18F
3CC8:  MOVFF  01,18E
3CCC:  MOVFF  00,18D
3CD0:  MOVLB  0
3CD2:  CALL   12EA
3CD6:  MOVFF  03,144
3CDA:  MOVFF  02,143
3CDE:  MOVFF  01,142
3CE2:  MOVFF  00,141
3CE6:  BCF    FD8.1
3CE8:  MOVFF  03,18C
3CEC:  MOVFF  02,18B
3CF0:  MOVFF  01,18A
3CF4:  MOVFF  00,189
3CF8:  MOVFF  7C,190
3CFC:  MOVFF  7B,18F
3D00:  MOVFF  7A,18E
3D04:  MOVFF  79,18D
3D08:  CALL   1574
3D0C:  MOVFF  03,8C
3D10:  MOVFF  02,8B
3D14:  MOVFF  01,8A
3D18:  MOVFF  00,89
....................         orto = 12 - ((2*ws)/15) + (tc1/60) - 2; //Hora de salida del sol 
3D1C:  MOVLB  1
3D1E:  CLRF   x8C
3D20:  CLRF   x8B
3D22:  CLRF   x8A
3D24:  MOVLW  80
3D26:  MOVWF  x89
3D28:  MOVFF  88,190
3D2C:  MOVFF  87,18F
3D30:  MOVFF  86,18E
3D34:  MOVFF  85,18D
3D38:  MOVLB  0
3D3A:  CALL   12EA
3D3E:  MOVFF  03,144
3D42:  MOVFF  02,143
3D46:  MOVFF  01,142
3D4A:  MOVFF  00,141
3D4E:  MOVFF  03,178
3D52:  MOVFF  02,177
3D56:  MOVFF  01,176
3D5A:  MOVFF  00,175
3D5E:  MOVLB  1
3D60:  CLRF   x7C
3D62:  CLRF   x7B
3D64:  MOVLW  70
3D66:  MOVWF  x7A
3D68:  MOVLW  82
3D6A:  MOVWF  x79
3D6C:  MOVLB  0
3D6E:  CALL   1416
3D72:  BSF    FD8.1
3D74:  MOVLB  1
3D76:  CLRF   x8C
3D78:  CLRF   x8B
3D7A:  MOVLW  40
3D7C:  MOVWF  x8A
3D7E:  MOVLW  82
3D80:  MOVWF  x89
3D82:  MOVFF  03,190
3D86:  MOVFF  02,18F
3D8A:  MOVFF  01,18E
3D8E:  MOVFF  00,18D
3D92:  MOVLB  0
3D94:  CALL   1574
3D98:  MOVFF  03,144
3D9C:  MOVFF  02,143
3DA0:  MOVFF  01,142
3DA4:  MOVFF  00,141
3DA8:  MOVFF  8C,178
3DAC:  MOVFF  8B,177
3DB0:  MOVFF  8A,176
3DB4:  MOVFF  89,175
3DB8:  MOVLB  1
3DBA:  CLRF   x7C
3DBC:  CLRF   x7B
3DBE:  MOVLW  70
3DC0:  MOVWF  x7A
3DC2:  MOVLW  84
3DC4:  MOVWF  x79
3DC6:  MOVLB  0
3DC8:  CALL   1416
3DCC:  BCF    FD8.1
3DCE:  MOVFF  144,18C
3DD2:  MOVFF  143,18B
3DD6:  MOVFF  142,18A
3DDA:  MOVFF  141,189
3DDE:  MOVFF  03,190
3DE2:  MOVFF  02,18F
3DE6:  MOVFF  01,18E
3DEA:  MOVFF  00,18D
3DEE:  CALL   1574
3DF2:  MOVFF  03,144
3DF6:  MOVFF  02,143
3DFA:  MOVFF  01,142
3DFE:  MOVFF  00,141
3E02:  BSF    FD8.1
3E04:  MOVFF  03,18C
3E08:  MOVFF  02,18B
3E0C:  MOVFF  01,18A
3E10:  MOVFF  00,189
3E14:  MOVLB  1
3E16:  CLRF   x90
3E18:  CLRF   x8F
3E1A:  CLRF   x8E
3E1C:  MOVLW  80
3E1E:  MOVWF  x8D
3E20:  MOVLB  0
3E22:  CALL   1574
3E26:  MOVFF  03,90
3E2A:  MOVFF  02,8F
3E2E:  MOVFF  01,8E
3E32:  MOVFF  00,8D
....................         ocaso = 24 + ((2*ws)/15) + (tc1/60) - 2; //Hora de puesta del sol 
3E36:  MOVLB  1
3E38:  CLRF   x8C
3E3A:  CLRF   x8B
3E3C:  CLRF   x8A
3E3E:  MOVLW  80
3E40:  MOVWF  x89
3E42:  MOVFF  88,190
3E46:  MOVFF  87,18F
3E4A:  MOVFF  86,18E
3E4E:  MOVFF  85,18D
3E52:  MOVLB  0
3E54:  CALL   12EA
3E58:  MOVFF  03,144
3E5C:  MOVFF  02,143
3E60:  MOVFF  01,142
3E64:  MOVFF  00,141
3E68:  MOVFF  03,178
3E6C:  MOVFF  02,177
3E70:  MOVFF  01,176
3E74:  MOVFF  00,175
3E78:  MOVLB  1
3E7A:  CLRF   x7C
3E7C:  CLRF   x7B
3E7E:  MOVLW  70
3E80:  MOVWF  x7A
3E82:  MOVLW  82
3E84:  MOVWF  x79
3E86:  MOVLB  0
3E88:  CALL   1416
3E8C:  BCF    FD8.1
3E8E:  MOVLB  1
3E90:  CLRF   x8C
3E92:  CLRF   x8B
3E94:  MOVLW  40
3E96:  MOVWF  x8A
3E98:  MOVLW  83
3E9A:  MOVWF  x89
3E9C:  MOVFF  03,190
3EA0:  MOVFF  02,18F
3EA4:  MOVFF  01,18E
3EA8:  MOVFF  00,18D
3EAC:  MOVLB  0
3EAE:  CALL   1574
3EB2:  MOVFF  03,144
3EB6:  MOVFF  02,143
3EBA:  MOVFF  01,142
3EBE:  MOVFF  00,141
3EC2:  MOVFF  8C,178
3EC6:  MOVFF  8B,177
3ECA:  MOVFF  8A,176
3ECE:  MOVFF  89,175
3ED2:  MOVLB  1
3ED4:  CLRF   x7C
3ED6:  CLRF   x7B
3ED8:  MOVLW  70
3EDA:  MOVWF  x7A
3EDC:  MOVLW  84
3EDE:  MOVWF  x79
3EE0:  MOVLB  0
3EE2:  CALL   1416
3EE6:  BCF    FD8.1
3EE8:  MOVFF  144,18C
3EEC:  MOVFF  143,18B
3EF0:  MOVFF  142,18A
3EF4:  MOVFF  141,189
3EF8:  MOVFF  03,190
3EFC:  MOVFF  02,18F
3F00:  MOVFF  01,18E
3F04:  MOVFF  00,18D
3F08:  CALL   1574
3F0C:  MOVFF  03,144
3F10:  MOVFF  02,143
3F14:  MOVFF  01,142
3F18:  MOVFF  00,141
3F1C:  BSF    FD8.1
3F1E:  MOVFF  03,18C
3F22:  MOVFF  02,18B
3F26:  MOVFF  01,18A
3F2A:  MOVFF  00,189
3F2E:  MOVLB  1
3F30:  CLRF   x90
3F32:  CLRF   x8F
3F34:  CLRF   x8E
3F36:  MOVLW  80
3F38:  MOVWF  x8D
3F3A:  MOVLB  0
3F3C:  CALL   1574
3F40:  MOVFF  03,A4
3F44:  MOVFF  02,A3
3F48:  MOVFF  01,A2
3F4C:  MOVFF  00,A1
....................  
....................         //Calculos variables, cada hora   
....................         //Tiempo estandar, tiempo solar verdadero  
....................         hor=atof(hora_c); 
3F50:  MOVLW  01
3F52:  MOVLB  1
3F54:  MOVWF  x42
3F56:  MOVLW  38
3F58:  MOVWF  x41
3F5A:  CLRF   x44
3F5C:  CLRF   x43
3F5E:  MOVLB  0
3F60:  CALL   17EC
3F64:  MOVFF  03,D4
3F68:  MOVFF  02,D3
3F6C:  MOVFF  01,D2
3F70:  MOVFF  00,D1
....................         minutos=atof(min_c); 
3F74:  MOVLW  01
3F76:  MOVLB  1
3F78:  MOVWF  x42
3F7A:  MOVLW  3B
3F7C:  MOVWF  x41
3F7E:  CLRF   x44
3F80:  CLRF   x43
3F82:  MOVLB  0
3F84:  CALL   17EC
3F88:  MOVFF  03,E8
3F8C:  MOVFF  02,E7
3F90:  MOVFF  01,E6
3F94:  MOVFF  00,E5
....................         sec=atof(seg_c); 
3F98:  MOVLW  01
3F9A:  MOVLB  1
3F9C:  MOVWF  x42
3F9E:  MOVLW  3E
3FA0:  MOVWF  x41
3FA2:  CLRF   x44
3FA4:  CLRF   x43
3FA6:  MOVLB  0
3FA8:  CALL   17EC
3FAC:  MOVFF  03,DC
3FB0:  MOVFF  02,DB
3FB4:  MOVFF  01,DA
3FB8:  MOVFF  00,D9
....................         horare = hor + (minutos/60) + (sec/3600); 
3FBC:  MOVFF  E8,178
3FC0:  MOVFF  E7,177
3FC4:  MOVFF  E6,176
3FC8:  MOVFF  E5,175
3FCC:  MOVLB  1
3FCE:  CLRF   x7C
3FD0:  CLRF   x7B
3FD2:  MOVLW  70
3FD4:  MOVWF  x7A
3FD6:  MOVLW  84
3FD8:  MOVWF  x79
3FDA:  MOVLB  0
3FDC:  CALL   1416
3FE0:  BCF    FD8.1
3FE2:  MOVFF  D4,18C
3FE6:  MOVFF  D3,18B
3FEA:  MOVFF  D2,18A
3FEE:  MOVFF  D1,189
3FF2:  MOVFF  03,190
3FF6:  MOVFF  02,18F
3FFA:  MOVFF  01,18E
3FFE:  MOVFF  00,18D
4002:  CALL   1574
4006:  MOVFF  03,144
400A:  MOVFF  02,143
400E:  MOVFF  01,142
4012:  MOVFF  00,141
4016:  MOVFF  DC,178
401A:  MOVFF  DB,177
401E:  MOVFF  DA,176
4022:  MOVFF  D9,175
4026:  MOVLB  1
4028:  CLRF   x7C
402A:  CLRF   x7B
402C:  MOVLW  61
402E:  MOVWF  x7A
4030:  MOVLW  8A
4032:  MOVWF  x79
4034:  MOVLB  0
4036:  CALL   1416
403A:  BCF    FD8.1
403C:  MOVFF  144,18C
4040:  MOVFF  143,18B
4044:  MOVFF  142,18A
4048:  MOVFF  141,189
404C:  MOVFF  03,190
4050:  MOVFF  02,18F
4054:  MOVFF  01,18E
4058:  MOVFF  00,18D
405C:  CALL   1574
4060:  MOVFF  03,E0
4064:  MOVFF  02,DF
4068:  MOVFF  01,DE
406C:  MOVFF  00,DD
....................         if (horare<orto){//alba (salida del sol) 
4070:  MOVFF  E0,188
4074:  MOVFF  DF,187
4078:  MOVFF  DE,186
407C:  MOVFF  DD,185
4080:  MOVFF  90,18C
4084:  MOVFF  8F,18B
4088:  MOVFF  8E,18A
408C:  MOVFF  8D,189
4090:  CALL   1A3A
4094:  BNC   40DA
....................           lcd_gotoxy(1,2);  
4096:  MOVLW  01
4098:  MOVLB  1
409A:  MOVWF  x4F
409C:  MOVLW  02
409E:  MOVWF  x50
40A0:  MOVLB  0
40A2:  CALL   025C
....................           printf(lcd_putc, "Alba: %f", orto); 
40A6:  MOVLW  6C
40A8:  MOVWF  FF6
40AA:  MOVLW  00
40AC:  MOVWF  FF7
40AE:  MOVLW  06
40B0:  MOVLB  1
40B2:  MOVWF  x41
40B4:  MOVLB  0
40B6:  CALL   285E
40BA:  MOVLW  89
40BC:  MOVWF  FE9
40BE:  MOVFF  90,144
40C2:  MOVFF  8F,143
40C6:  MOVFF  8E,142
40CA:  MOVFF  8D,141
40CE:  MOVLW  02
40D0:  MOVLB  1
40D2:  MOVWF  x45
40D4:  MOVLB  0
40D6:  CALL   2960
....................         } 
....................         if (horare>orto){ 
40DA:  MOVFF  90,188
40DE:  MOVFF  8F,187
40E2:  MOVFF  8E,186
40E6:  MOVFF  8D,185
40EA:  MOVFF  E0,18C
40EE:  MOVFF  DF,18B
40F2:  MOVFF  DE,18A
40F6:  MOVFF  DD,189
40FA:  CALL   1A3A
40FE:  BNC   4144
....................           lcd_gotoxy(1,2);  
4100:  MOVLW  01
4102:  MOVLB  1
4104:  MOVWF  x4F
4106:  MOVLW  02
4108:  MOVWF  x50
410A:  MOVLB  0
410C:  CALL   025C
....................           printf(lcd_putc, "Ocaso: %f", ocaso); 
4110:  MOVLW  76
4112:  MOVWF  FF6
4114:  MOVLW  00
4116:  MOVWF  FF7
4118:  MOVLW  07
411A:  MOVLB  1
411C:  MOVWF  x41
411E:  MOVLB  0
4120:  CALL   285E
4124:  MOVLW  89
4126:  MOVWF  FE9
4128:  MOVFF  A4,144
412C:  MOVFF  A3,143
4130:  MOVFF  A2,142
4134:  MOVFF  A1,141
4138:  MOVLW  02
413A:  MOVLB  1
413C:  MOVWF  x45
413E:  MOVLB  0
4140:  CALL   2960
....................         } 
....................         if (horare>ocaso){//(ocultamiento del sol) 
4144:  MOVFF  A4,188
4148:  MOVFF  A3,187
414C:  MOVFF  A2,186
4150:  MOVFF  A1,185
4154:  MOVFF  E0,18C
4158:  MOVFF  DF,18B
415C:  MOVFF  DE,18A
4160:  MOVFF  DD,189
4164:  CALL   1A3A
4168:  BTFSS  FD8.0
416A:  GOTO   4B92
....................           adia1 = (((2*pi)/365)*(da1-1))+1; //Ecuacion de dia 
416E:  BSF    FD8.1
4170:  MOVFF  C0,18C
4174:  MOVFF  BF,18B
4178:  MOVFF  BE,18A
417C:  MOVFF  BD,189
4180:  MOVLB  1
4182:  CLRF   x90
4184:  CLRF   x8F
4186:  CLRF   x8E
4188:  MOVLW  7F
418A:  MOVWF  x8D
418C:  MOVLB  0
418E:  CALL   1574
4192:  MOVLW  CF
4194:  MOVLB  1
4196:  MOVWF  x8C
4198:  MOVLW  04
419A:  MOVWF  x8B
419C:  MOVLW  0D
419E:  MOVWF  x8A
41A0:  MOVLW  79
41A2:  MOVWF  x89
41A4:  MOVFF  03,190
41A8:  MOVFF  02,18F
41AC:  MOVFF  01,18E
41B0:  MOVFF  00,18D
41B4:  MOVLB  0
41B6:  CALL   12EA
41BA:  MOVFF  03,144
41BE:  MOVFF  02,143
41C2:  MOVFF  01,142
41C6:  MOVFF  00,141
41CA:  BCF    FD8.1
41CC:  MOVFF  03,18C
41D0:  MOVFF  02,18B
41D4:  MOVFF  01,18A
41D8:  MOVFF  00,189
41DC:  MOVLB  1
41DE:  CLRF   x90
41E0:  CLRF   x8F
41E2:  CLRF   x8E
41E4:  MOVLW  7F
41E6:  MOVWF  x8D
41E8:  MOVLB  0
41EA:  CALL   1574
41EE:  MOVFF  03,D0
41F2:  MOVFF  02,CF
41F6:  MOVFF  01,CE
41FA:  MOVFF  00,CD
....................           eti =( //Resultado en minutos 
....................             ((0.000073) + (0.001868*(cos(adia1)))  
....................             - (0.0320777*(sin(adia1))) - (0.014615*(cos(2*adia1)))  
....................             - (0.04089*(sin(2*adia1))))*(229.18) 
....................           ); 
41FE:  MOVFF  D0,15E
4202:  MOVFF  CF,15D
4206:  MOVFF  CE,15C
420A:  MOVFF  CD,15B
420E:  CALL   1E6A
4212:  MOVLW  AE
4214:  MOVLB  1
4216:  MOVWF  x8C
4218:  MOVLW  D7
421A:  MOVWF  x8B
421C:  MOVLW  74
421E:  MOVWF  x8A
4220:  MOVLW  75
4222:  MOVWF  x89
4224:  MOVFF  03,190
4228:  MOVFF  02,18F
422C:  MOVFF  01,18E
4230:  MOVFF  00,18D
4234:  MOVLB  0
4236:  CALL   12EA
423A:  MOVFF  FEA,142
423E:  MOVFF  FE9,141
4242:  BCF    FD8.1
4244:  MOVLW  94
4246:  MOVLB  1
4248:  MOVWF  x8C
424A:  MOVLW  17
424C:  MOVWF  x8B
424E:  MOVLW  19
4250:  MOVWF  x8A
4252:  MOVLW  71
4254:  MOVWF  x89
4256:  MOVFF  03,190
425A:  MOVFF  02,18F
425E:  MOVFF  01,18E
4262:  MOVFF  00,18D
4266:  MOVLB  0
4268:  CALL   1574
426C:  MOVFF  142,FEA
4270:  MOVFF  141,FE9
4274:  MOVFF  03,146
4278:  MOVFF  02,145
427C:  MOVFF  01,144
4280:  MOVFF  00,143
4284:  MOVFF  D0,156
4288:  MOVFF  CF,155
428C:  MOVFF  CE,154
4290:  MOVFF  CD,153
4294:  CALL   2206
4298:  MOVLW  E8
429A:  MOVLB  1
429C:  MOVWF  x8C
429E:  MOVLW  63
42A0:  MOVWF  x8B
42A2:  MOVLW  03
42A4:  MOVWF  x8A
42A6:  MOVLW  7A
42A8:  MOVWF  x89
42AA:  MOVFF  03,190
42AE:  MOVFF  02,18F
42B2:  MOVFF  01,18E
42B6:  MOVFF  00,18D
42BA:  MOVLB  0
42BC:  CALL   12EA
42C0:  MOVFF  FEA,148
42C4:  MOVFF  FE9,147
42C8:  BSF    FD8.1
42CA:  MOVFF  146,18C
42CE:  MOVFF  145,18B
42D2:  MOVFF  144,18A
42D6:  MOVFF  143,189
42DA:  MOVFF  03,190
42DE:  MOVFF  02,18F
42E2:  MOVFF  01,18E
42E6:  MOVFF  00,18D
42EA:  CALL   1574
42EE:  MOVFF  148,FEA
42F2:  MOVFF  147,FE9
42F6:  MOVFF  03,146
42FA:  MOVFF  02,145
42FE:  MOVFF  01,144
4302:  MOVFF  00,143
4306:  MOVLB  1
4308:  CLRF   x8C
430A:  CLRF   x8B
430C:  CLRF   x8A
430E:  MOVLW  80
4310:  MOVWF  x89
4312:  MOVFF  D0,190
4316:  MOVFF  CF,18F
431A:  MOVFF  CE,18E
431E:  MOVFF  CD,18D
4322:  MOVLB  0
4324:  CALL   12EA
4328:  MOVFF  03,14C
432C:  MOVFF  02,14B
4330:  MOVFF  01,14A
4334:  MOVFF  00,149
4338:  MOVFF  03,15E
433C:  MOVFF  02,15D
4340:  MOVFF  01,15C
4344:  MOVFF  00,15B
4348:  CALL   1E6A
434C:  MOVLW  C1
434E:  MOVLB  1
4350:  MOVWF  x8C
4352:  MOVLW  73
4354:  MOVWF  x8B
4356:  MOVLW  6F
4358:  MOVWF  x8A
435A:  MOVLW  78
435C:  MOVWF  x89
435E:  MOVFF  03,190
4362:  MOVFF  02,18F
4366:  MOVFF  01,18E
436A:  MOVFF  00,18D
436E:  MOVLB  0
4370:  CALL   12EA
4374:  MOVFF  FEA,14A
4378:  MOVFF  FE9,149
437C:  BSF    FD8.1
437E:  MOVFF  146,18C
4382:  MOVFF  145,18B
4386:  MOVFF  144,18A
438A:  MOVFF  143,189
438E:  MOVFF  03,190
4392:  MOVFF  02,18F
4396:  MOVFF  01,18E
439A:  MOVFF  00,18D
439E:  CALL   1574
43A2:  MOVFF  14A,FEA
43A6:  MOVFF  149,FE9
43AA:  MOVFF  03,146
43AE:  MOVFF  02,145
43B2:  MOVFF  01,144
43B6:  MOVFF  00,143
43BA:  MOVLB  1
43BC:  CLRF   x8C
43BE:  CLRF   x8B
43C0:  CLRF   x8A
43C2:  MOVLW  80
43C4:  MOVWF  x89
43C6:  MOVFF  D0,190
43CA:  MOVFF  CF,18F
43CE:  MOVFF  CE,18E
43D2:  MOVFF  CD,18D
43D6:  MOVLB  0
43D8:  CALL   12EA
43DC:  MOVFF  03,14E
43E0:  MOVFF  02,14D
43E4:  MOVFF  01,14C
43E8:  MOVFF  00,14B
43EC:  MOVFF  03,156
43F0:  MOVFF  02,155
43F4:  MOVFF  01,154
43F8:  MOVFF  00,153
43FC:  CALL   2206
4400:  MOVLW  46
4402:  MOVLB  1
4404:  MOVWF  x8C
4406:  MOVLW  7C
4408:  MOVWF  x8B
440A:  MOVLW  27
440C:  MOVWF  x8A
440E:  MOVLW  7A
4410:  MOVWF  x89
4412:  MOVFF  03,190
4416:  MOVFF  02,18F
441A:  MOVFF  01,18E
441E:  MOVFF  00,18D
4422:  MOVLB  0
4424:  CALL   12EA
4428:  MOVFF  FEA,14C
442C:  MOVFF  FE9,14B
4430:  BSF    FD8.1
4432:  MOVFF  146,18C
4436:  MOVFF  145,18B
443A:  MOVFF  144,18A
443E:  MOVFF  143,189
4442:  MOVFF  03,190
4446:  MOVFF  02,18F
444A:  MOVFF  01,18E
444E:  MOVFF  00,18D
4452:  CALL   1574
4456:  MOVFF  14C,FEA
445A:  MOVFF  14B,FE9
445E:  MOVFF  03,146
4462:  MOVFF  02,145
4466:  MOVFF  01,144
446A:  MOVFF  00,143
446E:  MOVFF  03,18C
4472:  MOVFF  02,18B
4476:  MOVFF  01,18A
447A:  MOVFF  00,189
447E:  MOVLW  14
4480:  MOVLB  1
4482:  MOVWF  x90
4484:  MOVLW  2E
4486:  MOVWF  x8F
4488:  MOVLW  65
448A:  MOVWF  x8E
448C:  MOVLW  86
448E:  MOVWF  x8D
4490:  MOVLB  0
4492:  CALL   12EA
4496:  MOVFF  03,7C
449A:  MOVFF  02,7B
449E:  MOVFF  01,7A
44A2:  MOVFF  00,79
....................           //Correcion del tiempo, resultado en minutos 
....................           to = eti + (4*lon) - (60*-5); 
44A6:  MOVLB  1
44A8:  CLRF   x8C
44AA:  CLRF   x8B
44AC:  CLRF   x8A
44AE:  MOVLW  81
44B0:  MOVWF  x89
44B2:  MOVFF  78,190
44B6:  MOVFF  77,18F
44BA:  MOVFF  76,18E
44BE:  MOVFF  75,18D
44C2:  MOVLB  0
44C4:  CALL   12EA
44C8:  BCF    FD8.1
44CA:  MOVFF  7C,18C
44CE:  MOVFF  7B,18B
44D2:  MOVFF  7A,18A
44D6:  MOVFF  79,189
44DA:  MOVFF  03,190
44DE:  MOVFF  02,18F
44E2:  MOVFF  01,18E
44E6:  MOVFF  00,18D
44EA:  CALL   1574
44EE:  MOVFF  03,144
44F2:  MOVFF  02,143
44F6:  MOVFF  01,142
44FA:  MOVFF  00,141
44FE:  BSF    FD8.1
4500:  MOVFF  03,18C
4504:  MOVFF  02,18B
4508:  MOVFF  01,18A
450C:  MOVFF  00,189
4510:  MOVLB  1
4512:  CLRF   x90
4514:  CLRF   x8F
4516:  MOVLW  96
4518:  MOVWF  x8E
451A:  MOVLW  87
451C:  MOVWF  x8D
451E:  MOVLB  0
4520:  CALL   1574
4524:  MOVFF  03,84
4528:  MOVFF  02,83
452C:  MOVFF  01,82
4530:  MOVFF  00,81
....................           //Declinacion solar 
....................           dec1 =( 
....................             (0.006918-(0.39912*cos(adia1)) + (0.070257*sin(adia1))  
....................             - (0.006758*cos(2*adia1)) + (0.0009907*sin(2*adia1))  
....................             - (0.002697*cos(3*adia1))+(0.00148*sin(3*adia1))) 
....................           ); 
4534:  MOVFF  D0,15E
4538:  MOVFF  CF,15D
453C:  MOVFF  CE,15C
4540:  MOVFF  CD,15B
4544:  CALL   1E6A
4548:  MOVLW  75
454A:  MOVLB  1
454C:  MOVWF  x8C
454E:  MOVLW  59
4550:  MOVWF  x8B
4552:  MOVLW  4C
4554:  MOVWF  x8A
4556:  MOVLW  7D
4558:  MOVWF  x89
455A:  MOVFF  03,190
455E:  MOVFF  02,18F
4562:  MOVFF  01,18E
4566:  MOVFF  00,18D
456A:  MOVLB  0
456C:  CALL   12EA
4570:  MOVFF  FEA,142
4574:  MOVFF  FE9,141
4578:  BSF    FD8.1
457A:  MOVLW  64
457C:  MOVLB  1
457E:  MOVWF  x8C
4580:  MOVLW  B0
4582:  MOVWF  x8B
4584:  MOVLW  62
4586:  MOVWF  x8A
4588:  MOVLW  77
458A:  MOVWF  x89
458C:  MOVFF  03,190
4590:  MOVFF  02,18F
4594:  MOVFF  01,18E
4598:  MOVFF  00,18D
459C:  MOVLB  0
459E:  CALL   1574
45A2:  MOVFF  142,FEA
45A6:  MOVFF  141,FE9
45AA:  MOVFF  03,146
45AE:  MOVFF  02,145
45B2:  MOVFF  01,144
45B6:  MOVFF  00,143
45BA:  MOVFF  D0,156
45BE:  MOVFF  CF,155
45C2:  MOVFF  CE,154
45C6:  MOVFF  CD,153
45CA:  CALL   2206
45CE:  MOVLW  E7
45D0:  MOVLB  1
45D2:  MOVWF  x8C
45D4:  MOVLW  E2
45D6:  MOVWF  x8B
45D8:  MOVLW  0F
45DA:  MOVWF  x8A
45DC:  MOVLW  7B
45DE:  MOVWF  x89
45E0:  MOVFF  03,190
45E4:  MOVFF  02,18F
45E8:  MOVFF  01,18E
45EC:  MOVFF  00,18D
45F0:  MOVLB  0
45F2:  CALL   12EA
45F6:  MOVFF  FEA,148
45FA:  MOVFF  FE9,147
45FE:  BCF    FD8.1
4600:  MOVFF  146,18C
4604:  MOVFF  145,18B
4608:  MOVFF  144,18A
460C:  MOVFF  143,189
4610:  MOVFF  03,190
4614:  MOVFF  02,18F
4618:  MOVFF  01,18E
461C:  MOVFF  00,18D
4620:  CALL   1574
4624:  MOVFF  148,FEA
4628:  MOVFF  147,FE9
462C:  MOVFF  03,146
4630:  MOVFF  02,145
4634:  MOVFF  01,144
4638:  MOVFF  00,143
463C:  MOVLB  1
463E:  CLRF   x8C
4640:  CLRF   x8B
4642:  CLRF   x8A
4644:  MOVLW  80
4646:  MOVWF  x89
4648:  MOVFF  D0,190
464C:  MOVFF  CF,18F
4650:  MOVFF  CE,18E
4654:  MOVFF  CD,18D
4658:  MOVLB  0
465A:  CALL   12EA
465E:  MOVFF  03,14C
4662:  MOVFF  02,14B
4666:  MOVFF  01,14A
466A:  MOVFF  00,149
466E:  MOVFF  03,15E
4672:  MOVFF  02,15D
4676:  MOVFF  01,15C
467A:  MOVFF  00,15B
467E:  CALL   1E6A
4682:  MOVLW  36
4684:  MOVLB  1
4686:  MOVWF  x8C
4688:  MOVLW  72
468A:  MOVWF  x8B
468C:  MOVLW  5D
468E:  MOVWF  x8A
4690:  MOVLW  77
4692:  MOVWF  x89
4694:  MOVFF  03,190
4698:  MOVFF  02,18F
469C:  MOVFF  01,18E
46A0:  MOVFF  00,18D
46A4:  MOVLB  0
46A6:  CALL   12EA
46AA:  MOVFF  FEA,14A
46AE:  MOVFF  FE9,149
46B2:  BSF    FD8.1
46B4:  MOVFF  146,18C
46B8:  MOVFF  145,18B
46BC:  MOVFF  144,18A
46C0:  MOVFF  143,189
46C4:  MOVFF  03,190
46C8:  MOVFF  02,18F
46CC:  MOVFF  01,18E
46D0:  MOVFF  00,18D
46D4:  CALL   1574
46D8:  MOVFF  14A,FEA
46DC:  MOVFF  149,FE9
46E0:  MOVFF  03,146
46E4:  MOVFF  02,145
46E8:  MOVFF  01,144
46EC:  MOVFF  00,143
46F0:  MOVLB  1
46F2:  CLRF   x8C
46F4:  CLRF   x8B
46F6:  CLRF   x8A
46F8:  MOVLW  80
46FA:  MOVWF  x89
46FC:  MOVFF  D0,190
4700:  MOVFF  CF,18F
4704:  MOVFF  CE,18E
4708:  MOVFF  CD,18D
470C:  MOVLB  0
470E:  CALL   12EA
4712:  MOVFF  03,14E
4716:  MOVFF  02,14D
471A:  MOVFF  01,14C
471E:  MOVFF  00,14B
4722:  MOVFF  03,156
4726:  MOVFF  02,155
472A:  MOVFF  01,154
472E:  MOVFF  00,153
4732:  CALL   2206
4736:  MOVLW  60
4738:  MOVLB  1
473A:  MOVWF  x8C
473C:  MOVLW  DA
473E:  MOVWF  x8B
4740:  MOVLW  01
4742:  MOVWF  x8A
4744:  MOVLW  75
4746:  MOVWF  x89
4748:  MOVFF  03,190
474C:  MOVFF  02,18F
4750:  MOVFF  01,18E
4754:  MOVFF  00,18D
4758:  MOVLB  0
475A:  CALL   12EA
475E:  MOVFF  FEA,14C
4762:  MOVFF  FE9,14B
4766:  BCF    FD8.1
4768:  MOVFF  146,18C
476C:  MOVFF  145,18B
4770:  MOVFF  144,18A
4774:  MOVFF  143,189
4778:  MOVFF  03,190
477C:  MOVFF  02,18F
4780:  MOVFF  01,18E
4784:  MOVFF  00,18D
4788:  CALL   1574
478C:  MOVFF  14C,FEA
4790:  MOVFF  14B,FE9
4794:  MOVFF  03,146
4798:  MOVFF  02,145
479C:  MOVFF  01,144
47A0:  MOVFF  00,143
47A4:  MOVLB  1
47A6:  CLRF   x8C
47A8:  CLRF   x8B
47AA:  MOVLW  40
47AC:  MOVWF  x8A
47AE:  MOVLW  80
47B0:  MOVWF  x89
47B2:  MOVFF  D0,190
47B6:  MOVFF  CF,18F
47BA:  MOVFF  CE,18E
47BE:  MOVFF  CD,18D
47C2:  MOVLB  0
47C4:  CALL   12EA
47C8:  MOVFF  03,150
47CC:  MOVFF  02,14F
47D0:  MOVFF  01,14E
47D4:  MOVFF  00,14D
47D8:  MOVFF  03,15E
47DC:  MOVFF  02,15D
47E0:  MOVFF  01,15C
47E4:  MOVFF  00,15B
47E8:  CALL   1E6A
47EC:  MOVLW  27
47EE:  MOVLB  1
47F0:  MOVWF  x8C
47F2:  MOVLW  C0
47F4:  MOVWF  x8B
47F6:  MOVLW  30
47F8:  MOVWF  x8A
47FA:  MOVLW  76
47FC:  MOVWF  x89
47FE:  MOVFF  03,190
4802:  MOVFF  02,18F
4806:  MOVFF  01,18E
480A:  MOVFF  00,18D
480E:  MOVLB  0
4810:  CALL   12EA
4814:  MOVFF  FEA,14E
4818:  MOVFF  FE9,14D
481C:  BSF    FD8.1
481E:  MOVFF  146,18C
4822:  MOVFF  145,18B
4826:  MOVFF  144,18A
482A:  MOVFF  143,189
482E:  MOVFF  03,190
4832:  MOVFF  02,18F
4836:  MOVFF  01,18E
483A:  MOVFF  00,18D
483E:  CALL   1574
4842:  MOVFF  14E,FEA
4846:  MOVFF  14D,FE9
484A:  MOVFF  03,146
484E:  MOVFF  02,145
4852:  MOVFF  01,144
4856:  MOVFF  00,143
485A:  MOVLB  1
485C:  CLRF   x8C
485E:  CLRF   x8B
4860:  MOVLW  40
4862:  MOVWF  x8A
4864:  MOVLW  80
4866:  MOVWF  x89
4868:  MOVFF  D0,190
486C:  MOVFF  CF,18F
4870:  MOVFF  CE,18E
4874:  MOVFF  CD,18D
4878:  MOVLB  0
487A:  CALL   12EA
487E:  MOVFF  03,152
4882:  MOVFF  02,151
4886:  MOVFF  01,150
488A:  MOVFF  00,14F
488E:  MOVFF  03,156
4892:  MOVFF  02,155
4896:  MOVFF  01,154
489A:  MOVFF  00,153
489E:  CALL   2206
48A2:  MOVLW  8F
48A4:  MOVLB  1
48A6:  MOVWF  x8C
48A8:  MOVLW  FC
48AA:  MOVWF  x8B
48AC:  MOVLW  41
48AE:  MOVWF  x8A
48B0:  MOVLW  75
48B2:  MOVWF  x89
48B4:  MOVFF  03,190
48B8:  MOVFF  02,18F
48BC:  MOVFF  01,18E
48C0:  MOVFF  00,18D
48C4:  MOVLB  0
48C6:  CALL   12EA
48CA:  MOVFF  FEA,150
48CE:  MOVFF  FE9,14F
48D2:  BCF    FD8.1
48D4:  MOVFF  146,18C
48D8:  MOVFF  145,18B
48DC:  MOVFF  144,18A
48E0:  MOVFF  143,189
48E4:  MOVFF  03,190
48E8:  MOVFF  02,18F
48EC:  MOVFF  01,18E
48F0:  MOVFF  00,18D
48F4:  CALL   1574
48F8:  MOVFF  150,FEA
48FC:  MOVFF  14F,FE9
4900:  MOVFF  03,80
4904:  MOVFF  02,7F
4908:  MOVFF  01,7E
490C:  MOVFF  00,7D
....................           //Angulo horario a la salida del sol 
....................           ws = (acos(-tan(lat)*tan(dec1))); 
4910:  MOVFF  74,148
4914:  MOVFF  73,147
4918:  MOVFF  72,146
491C:  MOVFF  71,145
4920:  CALL   2254
4924:  MOVFF  00,141
4928:  MOVF   01,W
492A:  XORLW  80
492C:  MOVLB  1
492E:  MOVWF  x42
4930:  MOVFF  02,143
4934:  MOVFF  03,144
4938:  MOVFF  80,148
493C:  MOVFF  7F,147
4940:  MOVFF  7E,146
4944:  MOVFF  7D,145
4948:  MOVLB  0
494A:  CALL   2254
494E:  MOVFF  144,18C
4952:  MOVFF  143,18B
4956:  MOVFF  142,18A
495A:  MOVFF  141,189
495E:  MOVFF  03,190
4962:  MOVFF  02,18F
4966:  MOVFF  01,18E
496A:  MOVFF  00,18D
496E:  CALL   12EA
4972:  MOVFF  03,144
4976:  MOVFF  02,143
497A:  MOVFF  01,142
497E:  MOVFF  00,141
4982:  MOVFF  03,148
4986:  MOVFF  02,147
498A:  MOVFF  01,146
498E:  MOVFF  00,145
4992:  CALL   2822
4996:  MOVFF  03,88
499A:  MOVFF  02,87
499E:  MOVFF  01,86
49A2:  MOVFF  00,85
....................           tc1 = 4*(lon+(15*5))+eti; 
49A6:  BCF    FD8.1
49A8:  MOVFF  78,18C
49AC:  MOVFF  77,18B
49B0:  MOVFF  76,18A
49B4:  MOVFF  75,189
49B8:  MOVLB  1
49BA:  CLRF   x90
49BC:  CLRF   x8F
49BE:  MOVLW  16
49C0:  MOVWF  x8E
49C2:  MOVLW  85
49C4:  MOVWF  x8D
49C6:  MOVLB  0
49C8:  CALL   1574
49CC:  MOVLB  1
49CE:  CLRF   x8C
49D0:  CLRF   x8B
49D2:  CLRF   x8A
49D4:  MOVLW  81
49D6:  MOVWF  x89
49D8:  MOVFF  03,190
49DC:  MOVFF  02,18F
49E0:  MOVFF  01,18E
49E4:  MOVFF  00,18D
49E8:  MOVLB  0
49EA:  CALL   12EA
49EE:  MOVFF  03,144
49F2:  MOVFF  02,143
49F6:  MOVFF  01,142
49FA:  MOVFF  00,141
49FE:  BCF    FD8.1
4A00:  MOVFF  03,18C
4A04:  MOVFF  02,18B
4A08:  MOVFF  01,18A
4A0C:  MOVFF  00,189
4A10:  MOVFF  7C,190
4A14:  MOVFF  7B,18F
4A18:  MOVFF  7A,18E
4A1C:  MOVFF  79,18D
4A20:  CALL   1574
4A24:  MOVFF  03,8C
4A28:  MOVFF  02,8B
4A2C:  MOVFF  01,8A
4A30:  MOVFF  00,89
....................           orto = 12 - ((2*ws)/15) + (tc1/60) - 2; //Hora de salida del sol 
4A34:  MOVLB  1
4A36:  CLRF   x8C
4A38:  CLRF   x8B
4A3A:  CLRF   x8A
4A3C:  MOVLW  80
4A3E:  MOVWF  x89
4A40:  MOVFF  88,190
4A44:  MOVFF  87,18F
4A48:  MOVFF  86,18E
4A4C:  MOVFF  85,18D
4A50:  MOVLB  0
4A52:  CALL   12EA
4A56:  MOVFF  03,144
4A5A:  MOVFF  02,143
4A5E:  MOVFF  01,142
4A62:  MOVFF  00,141
4A66:  MOVFF  03,178
4A6A:  MOVFF  02,177
4A6E:  MOVFF  01,176
4A72:  MOVFF  00,175
4A76:  MOVLB  1
4A78:  CLRF   x7C
4A7A:  CLRF   x7B
4A7C:  MOVLW  70
4A7E:  MOVWF  x7A
4A80:  MOVLW  82
4A82:  MOVWF  x79
4A84:  MOVLB  0
4A86:  CALL   1416
4A8A:  BSF    FD8.1
4A8C:  MOVLB  1
4A8E:  CLRF   x8C
4A90:  CLRF   x8B
4A92:  MOVLW  40
4A94:  MOVWF  x8A
4A96:  MOVLW  82
4A98:  MOVWF  x89
4A9A:  MOVFF  03,190
4A9E:  MOVFF  02,18F
4AA2:  MOVFF  01,18E
4AA6:  MOVFF  00,18D
4AAA:  MOVLB  0
4AAC:  CALL   1574
4AB0:  MOVFF  03,144
4AB4:  MOVFF  02,143
4AB8:  MOVFF  01,142
4ABC:  MOVFF  00,141
4AC0:  MOVFF  8C,178
4AC4:  MOVFF  8B,177
4AC8:  MOVFF  8A,176
4ACC:  MOVFF  89,175
4AD0:  MOVLB  1
4AD2:  CLRF   x7C
4AD4:  CLRF   x7B
4AD6:  MOVLW  70
4AD8:  MOVWF  x7A
4ADA:  MOVLW  84
4ADC:  MOVWF  x79
4ADE:  MOVLB  0
4AE0:  CALL   1416
4AE4:  BCF    FD8.1
4AE6:  MOVFF  144,18C
4AEA:  MOVFF  143,18B
4AEE:  MOVFF  142,18A
4AF2:  MOVFF  141,189
4AF6:  MOVFF  03,190
4AFA:  MOVFF  02,18F
4AFE:  MOVFF  01,18E
4B02:  MOVFF  00,18D
4B06:  CALL   1574
4B0A:  MOVFF  03,144
4B0E:  MOVFF  02,143
4B12:  MOVFF  01,142
4B16:  MOVFF  00,141
4B1A:  BSF    FD8.1
4B1C:  MOVFF  03,18C
4B20:  MOVFF  02,18B
4B24:  MOVFF  01,18A
4B28:  MOVFF  00,189
4B2C:  MOVLB  1
4B2E:  CLRF   x90
4B30:  CLRF   x8F
4B32:  CLRF   x8E
4B34:  MOVLW  80
4B36:  MOVWF  x8D
4B38:  MOVLB  0
4B3A:  CALL   1574
4B3E:  MOVFF  03,90
4B42:  MOVFF  02,8F
4B46:  MOVFF  01,8E
4B4A:  MOVFF  00,8D
....................           lcd_gotoxy(1,2); printf(lcd_putc, "Alba: %f", orto); 
4B4E:  MOVLW  01
4B50:  MOVLB  1
4B52:  MOVWF  x4F
4B54:  MOVLW  02
4B56:  MOVWF  x50
4B58:  MOVLB  0
4B5A:  CALL   025C
4B5E:  MOVLW  80
4B60:  MOVWF  FF6
4B62:  MOVLW  00
4B64:  MOVWF  FF7
4B66:  MOVLW  06
4B68:  MOVLB  1
4B6A:  MOVWF  x41
4B6C:  MOVLB  0
4B6E:  CALL   285E
4B72:  MOVLW  89
4B74:  MOVWF  FE9
4B76:  MOVFF  90,144
4B7A:  MOVFF  8F,143
4B7E:  MOVFF  8E,142
4B82:  MOVFF  8D,141
4B86:  MOVLW  02
4B88:  MOVLB  1
4B8A:  MOVWF  x45
4B8C:  MOVLB  0
4B8E:  CALL   2960
....................         } 
....................           
....................         /* 
....................         tst = (hor*60) + minutos + (sec/60) + to; 
....................         //Angulo solar  
....................         ha = (tst/4) - (180); 
....................         haa = ha*0.01745333; 
....................         //Angulo Zenith 
....................         zenit =   acos(((sin(lat))*(sin(dec1))) + ((cos(lat))*(cos(dec1))*(cos(haa)))); 
....................         //Angulo Azimutal 
....................         if (ha<0) {azimut = (pi +  ((-acos(((sin(lat)*cos(zenit)) - sin(dec1))/(cos(lat)*sin(zenit))))))*57.2958; } 
....................         if (ha>0) {azimut = (6.28319 - (((-acos(((sin(lat)*cos(zenit)) - sin(dec1))/(cos(lat)*sin(zenit)))))))*57.2958;} 
....................         lcd_gotoxy(1,2); printf(lcd_putc, "Azimut Sol: %f", azimut); 
....................         */ 
....................       } 
....................   
....................     } 
4B92:  GOTO   2C1E
....................   
....................   } 
....................   
.................... } 
.................... // End of code. Code 
4B96:  SLEEP 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: C83F   PLL12 CPUDIV4 USBDIV INTRC_IO FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
